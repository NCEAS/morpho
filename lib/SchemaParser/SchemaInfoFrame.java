import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.tree.*;
import com.symantec.itools.javax.swing.JToolBarSeparator;
import com.symantec.itools.javax.swing.icons.ImageIcon;
import java.util.*;
import java.io.*;

import org.apache.xerces.impl.xs.psvi.*;



/**
 * A basic JFC 1.1 based application.
 */
public class SchemaInfoFrame extends javax.swing.JFrame
{
    String publicIDString = null;
    String systemIDString = null;
    StringBuffer sb;
    StringBuffer start;
    Stack tempStack;
    boolean textnode = false;
    
    NodeInfo topni = new NodeInfo("Schema");
    DefaultMutableTreeNode top = new DefaultMutableTreeNode(topni);
    
    XSModel xsmodel;
    
    int cnt=0;
    
    
	public SchemaInfoFrame()
	{
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		setTitle("XML Schema PSVI Display");
		setDefaultCloseOperation(javax.swing.JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout(0,0));
		setSize(600,309);
		setVisible(false);
		saveFileDialog.setMode(FileDialog.SAVE);
		saveFileDialog.setTitle("Save");
		//$$ saveFileDialog.move(24,336);
		openFileDialog.setMode(FileDialog.LOAD);
		openFileDialog.setTitle("Open");
		//$$ openFileDialog.move(0,336);
		TopPanel.setLayout(new BorderLayout(0,0));
		getContentPane().add(BorderLayout.CENTER, TopPanel);
		SchemaNamePanel.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
		TopPanel.add(BorderLayout.NORTH, SchemaNamePanel);
		SchemaNameTextField.setText("eml.xsd");
		SchemaNameTextField.setColumns(20);
		SchemaNamePanel.add(SchemaNameTextField);
		getXSModel.setText("Get XSModel");
		getXSModel.setActionCommand("Get XSModel");
		SchemaNamePanel.add(getXSModel);
		globalElementsButton.setText("Get Global Elements");
		globalElementsButton.setActionCommand("jbutton");
		SchemaNamePanel.add(globalElementsButton);
		SaveButton.setText("Save");
		SaveButton.setActionCommand("Save");
		SchemaNamePanel.add(SaveButton);
		JPanel1.setLayout(new BorderLayout(0,0));
		TopPanel.add(BorderLayout.CENTER, JPanel1);
		JPanel3.setLayout(new BorderLayout(0,0));
		JPanel1.add(BorderLayout.CENTER, JPanel3);
		JScrollPane1.setOpaque(true);
		JPanel3.add(BorderLayout.CENTER, JScrollPane1);
		JScrollPane1.getViewport().add(tree);
		tree.setBounds(0,0,78,72);
		NodePropsPanel.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
		TopPanel.add(BorderLayout.SOUTH, NodePropsPanel);
		NodePropsLabel.setText("Properties:");
		NodePropsPanel.add(NodePropsLabel);
		//}}

		//{{INIT_MENUS
		//}}

		//{{REGISTER_LISTENERS
		SymWindow aSymWindow = new SymWindow();
		this.addWindowListener(aSymWindow);
		SymAction lSymAction = new SymAction();
		getXSModel.addActionListener(lSymAction);
		globalElementsButton.addActionListener(lSymAction);
		SymTreeSelection lSymTreeSelection = new SymTreeSelection();
		tree.addTreeSelectionListener(lSymTreeSelection);
		SaveButton.addActionListener(lSymAction);
		//}}
		
//		tree.setCellRenderer(new XMLTreeCellRenderer());

    tree.setShowsRootHandles(true);
    tree.setEditable(false);
    tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
    tree.setShowsRootHandles(true);
    tree.putClientProperty("JTree.lineStyle", "Angled");

		xsmodel = SchemaStructure.getXSModel(SchemaNameTextField.getText());
		if (xsmodel==null) System.out.println("XSModel is null!!!!!!");
		if (xsmodel!=null) {
		  createNodes(top);
		  DefaultTreeModel treeModel = new DefaultTreeModel(top);
		  tree.setModel(treeModel);
		}
		
	}

    /**
     * Creates a new instance of JFrame1 with the given title.
     * @param sTitle the title for the new frame.
     * @see #JFrame1()
     */
	public SchemaInfoFrame(String sTitle)
	{
		this();
		setTitle(sTitle);
	}
	
	/**
	 * The entry point for this application.
	 * Sets the Look and Feel to the System Look and Feel.
	 * Creates a new JFrame1 and makes it visible.
	 */
	static public void main(String args[])
	{
		try {
		    // Add the following code if you want the Look and Feel
		    // to be set to the Look and Feel of the native system.
		    /*
		    try {
		        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		    } 
		    catch (Exception e) { 
		    }
		    */

			//Create a new instance of our application's frame, and make it visible.
			(new SchemaInfoFrame()).setVisible(true);
		} 
		catch (Throwable t) {
			t.printStackTrace();
			//Ensure the application exits with an error condition.
			System.exit(1);
		}
	}

    /**
     * Notifies this component that it has been added to a container
     * This method should be called by <code>Container.add</code>, and 
     * not by user code directly.
     * Overridden here to adjust the size of the frame if needed.
     * @see java.awt.Container#removeNotify
     */
	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension size = getSize();
		
		super.addNotify();
		
		if (frameSizeAdjusted)
			return;
		frameSizeAdjusted = true;
		
		// Adjust size of frame according to the insets and menu bar
		javax.swing.JMenuBar menuBar = getRootPane().getJMenuBar();
		int menuBarHeight = 0;
		if (menuBar != null)
		    menuBarHeight = menuBar.getPreferredSize().height;
		Insets insets = getInsets();
		setSize(insets.left + insets.right + size.width, insets.top + insets.bottom + size.height + menuBarHeight);
	}

	// Used by addNotify
	boolean frameSizeAdjusted = false;

	//{{DECLARE_CONTROLS
	java.awt.FileDialog saveFileDialog = new java.awt.FileDialog(this);
	java.awt.FileDialog openFileDialog = new java.awt.FileDialog(this);
	javax.swing.JPanel TopPanel = new javax.swing.JPanel();
	javax.swing.JPanel SchemaNamePanel = new javax.swing.JPanel();
	javax.swing.JTextField SchemaNameTextField = new javax.swing.JTextField();
	javax.swing.JButton getXSModel = new javax.swing.JButton();
	javax.swing.JButton globalElementsButton = new javax.swing.JButton();
	javax.swing.JButton SaveButton = new javax.swing.JButton();
	javax.swing.JPanel JPanel1 = new javax.swing.JPanel();
	javax.swing.JPanel JPanel3 = new javax.swing.JPanel();
	javax.swing.JScrollPane JScrollPane1 = new javax.swing.JScrollPane();
	javax.swing.JTree tree = new javax.swing.JTree();
	javax.swing.JPanel NodePropsPanel = new javax.swing.JPanel();
	javax.swing.JLabel NodePropsLabel = new javax.swing.JLabel();
	//}}

	//{{DECLARE_MENUS
	//}}

	void exitApplication()
	{
		try {
	    	// Beep
	    	Toolkit.getDefaultToolkit().beep();
	    	// Show a confirmation dialog
	    	int reply = JOptionPane.showConfirmDialog(this, 
	    	                                          "Do you really want to exit?", 
	    	                                          "JFC Application - Exit" , 
	    	                                          JOptionPane.YES_NO_OPTION, 
	    	                                          JOptionPane.QUESTION_MESSAGE);
			// If the confirmation was affirmative, handle exiting.
			if (reply == JOptionPane.YES_OPTION)
			{
		    	this.setVisible(false);    // hide the Frame
		    	this.dispose();            // free the system resources
		    	System.exit(0);            // close the application
			}
		} catch (Exception e) {
		}
	}

	class SymWindow extends java.awt.event.WindowAdapter
	{
		public void windowClosing(java.awt.event.WindowEvent event)
		{
			Object object = event.getSource();
			if (object == SchemaInfoFrame.this)
				SchemaInfoFrame_windowClosing(event);
		}
	}

	void SchemaInfoFrame_windowClosing(java.awt.event.WindowEvent event)
	{
		// to do: code goes here.
			 
		SchemaInfoFrame_windowClosing_Interaction1(event);
	}

	void SchemaInfoFrame_windowClosing_Interaction1(java.awt.event.WindowEvent event) {
		try {
			this.exitApplication();
		} catch (Exception e) {
		}
	}

	class SymAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			if (object == getXSModel)
				getXSModel_actionPerformed(event);
			else if (object == globalElementsButton)
				globalElementsButton_actionPerformed(event);
			else if (object == SaveButton)
				SaveButton_actionPerformed(event);
			
		}
	}

	void getXSModel_actionPerformed(java.awt.event.ActionEvent event)
	{
		xsmodel = SchemaStructure.getXSModel(SchemaNameTextField.getText());
		if (xsmodel==null) System.out.println("XSModel is null!!!!!!");
	}

	void globalElementsButton_actionPerformed(java.awt.event.ActionEvent event)
	{
		if (xsmodel!=null) {
		  createNodes(top);
		  DefaultTreeModel treeModel = new DefaultTreeModel(top);
		  tree.setModel(treeModel);
		}
	}
	
	void createNodes(DefaultMutableTreeNode top) {
	    NodeInfo geni = new NodeInfo("Global Elements");
	    DefaultMutableTreeNode globalElements = new DefaultMutableTreeNode(geni);
	    if (xsmodel!=null) {
	      Vector vec = SchemaStructure.getGlobalElements(xsmodel);
	      for (int i=0; i<vec.size();i++) {
	        String name = (String)vec.elementAt(i);
//	        DefaultMutableTreeNode nd = new DefaultMutableTreeNode(name);
	        DefaultMutableTreeNode nd = SchemaStructure.getElementInfoFromName(xsmodel, name);
	        
	        
	        globalElements.add(nd);
	      }
	    }
	    NodeInfo gani = new NodeInfo("Global Attributes");
	    DefaultMutableTreeNode globalAttributes = new DefaultMutableTreeNode(gani);
	    if (xsmodel!=null) {
	      Vector vec = SchemaStructure.getGlobalAttributes(xsmodel);
	      for (int i=0; i<vec.size();i++) {
	        globalAttributes.add(new DefaultMutableTreeNode((String)vec.elementAt(i)));
	      }
	    }
	    NodeInfo ggni = new NodeInfo("Groups");
	    DefaultMutableTreeNode globalGroups = new DefaultMutableTreeNode(ggni);
	    if (xsmodel!=null) {
	      Vector vec = SchemaStructure.getGlobalModelGroups(xsmodel);
	      for (int i=0; i<vec.size();i++) {
	        globalGroups.add(new DefaultMutableTreeNode((String)vec.elementAt(i)));
	      }
	    }
	    NodeInfo gct = new NodeInfo("Global Complex Types");
	    DefaultMutableTreeNode globalComplexTypes = new DefaultMutableTreeNode(gct);
	    if (xsmodel!=null) {
	      Vector vec = SchemaStructure.getGlobalComplexTypes(xsmodel);
	      for (int i=0; i<vec.size();i++) {
	        globalComplexTypes.add(new DefaultMutableTreeNode((String)vec.elementAt(i)));
	      }
	    }
	    NodeInfo nsni = new NodeInfo("Namespaces");
	    DefaultMutableTreeNode namespaces = new DefaultMutableTreeNode(nsni);
	    if (xsmodel!=null) {
	      Vector vec = SchemaStructure.getNameSpaces(xsmodel);
	      for (int i=0; i<vec.size();i++) {
	        namespaces.add(new DefaultMutableTreeNode((String)vec.elementAt(i)));
	      }
	    }
	    top.add(globalElements);
	    top.add(globalAttributes);
	    top.add(globalComplexTypes);
	    top.add(globalGroups);
	    top.add(namespaces);
	    
	    DefaultMutableTreeNode globalelem = (DefaultMutableTreeNode)(top.getFirstChild());
	    DefaultMutableTreeNode eml = (DefaultMutableTreeNode)(globalelem.getFirstChild());
	    getNodeCount(eml);
	}
	
	void getNodeCount(DefaultMutableTreeNode nd) {
	    int cnt = 0;
	    Enumeration enum = nd.depthFirstEnumeration();
	    while (enum.hasMoreElements()) {
	        cnt++;
	        enum.nextElement();
	    }
	    System.out.println(">>>>>>>>Starting node: "+nd.getUserObject().toString());
	    System.out.println(">>>>>>>>Number of node in tree: "+cnt);
	}

	class SymTreeSelection implements javax.swing.event.TreeSelectionListener
	{
		public void valueChanged(javax.swing.event.TreeSelectionEvent event)
		{
			Object object = event.getSource();
			if (object == tree)
				tree_valueChanged(event);
		}
	}

	void tree_valueChanged(javax.swing.event.TreeSelectionEvent event)
	{
	  TreePath tp = event.getNewLeadSelectionPath();
    if (tp != null) {
      Object ob = tp.getLastPathComponent();
      DefaultMutableTreeNode node = null;
      if (ob != null) {
        node = (DefaultMutableTreeNode)ob;
      }
       NodeInfo ni = (NodeInfo)node.getUserObject();
       String props = "MinOccurs:"+ni.getMinOcc()+" MaxOccurs:"+ni.getMaxOcc();
       Hashtable hash = ni.getAttributes();
       if (hash!=null) {
         Enumeration enum = hash.keys();
         while(enum.hasMoreElements()) {
           String keyval = (String)enum.nextElement();
           props = props+" "+keyval+":"+(String)(hash.get(keyval));
         }
       }
       NodePropsLabel.setText(props);
    }
	}
	
    /*
        write the tree starting at the indicated node to a File named 'fn'
      */
    /**
     * write the tree starting at the indicated node to a File named 'fn'
     * i.e. serializes the tree to xml in a file
     *
     * @param node  top level node
     * @param fn    file name
     */
    void writeXML(DefaultMutableTreeNode node, String fn)
    {
        cnt=0;
        //setSelectedNodes(node);
        trimAttributeNames(node);  // remove extra info in attribute nodes
        File outputFile = new File(fn);
        try {
            FileWriter out = new FileWriter(outputFile);
            tempStack = new Stack();
            start = new StringBuffer();
            write_loop(node, 0);
            String str1 = start.toString();

            String doctype = "";
            if (publicIDString != null) {
                String rootNodeName = 
                    ((NodeInfo)node.getUserObject()).getName();
                String temp = "";
                if (publicIDString != null) {
                    temp = "\"" + publicIDString + "\"";
                }
                String temp1 = "";
                if (systemIDString != null) {
                    temp1 = "\"file://" + systemIDString + "\"";
                }
                doctype = "<!DOCTYPE " + rootNodeName + " PUBLIC " + 
                    temp + " " + temp1 + ">\n";
            }
            str1 = "<?xml version=\"1.0\"?>\n" + doctype + str1;

            out.write(str1);
            out.close();
        } catch (Exception e) {}
    }

  /**
   * need to trim extra text added to attribute nodes before saving
   *
   */
  void trimAttributeNames(DefaultMutableTreeNode root) {
    Enumeration kids = root.children();
    while(kids.hasMoreElements()) {
      DefaultMutableTreeNode node = (DefaultMutableTreeNode)kids.nextElement();
      NodeInfo ni = (NodeInfo)node.getUserObject();
      if(ni.toString().startsWith("attribute")) {  // an attribute node
        ni.setName("attribute");
      }
    }
  }

    /*
        recursive routine to create xml output
      */
    /**
     * recursive routine to create xml output
     *
     * @param node    starting node
     * @param indent  indent level
     */
    void write_loop(DefaultMutableTreeNode node, int indent)
    {
        String indentString = "";
        while (indentString.length() < indent) {
            indentString = indentString + " ";
        }
        StringBuffer start1 = new StringBuffer();
        String name;
        String end;
//	  boolean emptyFlag = true;
        boolean emptyNodeParent = false;
        NodeInfo ni = (NodeInfo)node.getUserObject();
        name = ni.name;
//	  if (!((ni.getCardinality()).equals("NOT SELECTED"))) {
        if ((!ni.isChoice()) || (ni.isChoice() && (ni.isSelected()))) {
            // completely ignore NOT SELECTED nodes AND their children
            if ((!name.startsWith("(CHOICE)")) && 
                (!name.startsWith("(SEQUENCE)")) && (!name.equals("Empty"))
//DFH                && !((name.indexOf("SEQUENCE")>-1)&&(((ni.getMinOcc().equals(ni.getMaxOcc())))))
                ) {
                // ignore (CHOICE) nodes but process their children
                if ((name.indexOf("SEQUENCE")>-1)|| (name.indexOf("CHOICE")>-1)){
                  name = name+cnt;
                  cnt++;
                }
                start1.append("\n" + indentString + "<" + name);

                Enumeration keys = (ni.attr).keys();
                while (keys.hasMoreElements()) {
                    String str = (String)(keys.nextElement());
                    String val = (String)((ni.attr).get(str));
                    start1.append(" " + str + "=\"" + val + "\"");
                }
                // add the cardinality info as xml attribute
                    start1.append(" "+"minOccurs=\""+ni.getMinOcc()+"\" maxOccurs=\""+ni.getMaxOcc()+"\"");
                    
                    String help = "";
                    String helps = ni.getHelp();
                    if (helps!=null) {
                      int start = helps.indexOf("<doc:summary >")+14;
                      int stop = helps.indexOf("</doc:summary");
                      help = helps.substring(start, stop);
                    }
                    
                    start1.append(" "+"help=\""+help+"\"");

                start1.append(">");
                end = "</" + name + ">";
                tempStack.push(end);
            }
            Enumeration enum = node.children();

// if enum has no elements, then node is a leaf node
            if (!enum.hasMoreElements()) {
                start.append(start1.toString());
                start1 = new StringBuffer();
//	      textnode = true;
            }

            while (enum.hasMoreElements()) {
                // process child nodes
                DefaultMutableTreeNode nd = 
                    (DefaultMutableTreeNode)(enum.nextElement());
                NodeInfo ni1 = (NodeInfo)nd.getUserObject();
                if (ni1.name.equals("#PCDATA")) {
                    // remove nodes with empty PCDATA
                    String pcdata = ni1.getPCValue();
//                    if (emptyFlag) {
                    if (false) {
                        if (pcdata.trim().length() < 1) {
                            String card = ni.getCardinality();
                            if ((card.equals("ZERO to MANY")) || 
                                (card.equals("OPTIONAL"))) {
                                start1 = new StringBuffer();
                                tempStack.pop();
                                tempStack.push("");
                            }
                        }
                    }
                    start.append(start1.toString());
                    start1 = new StringBuffer();
//                    start.append(XMLUtil.normalize(ni1.getPCValue()));
                    start.append(ni1.getPCValue());
                    textnode = true;
                } else if (ni1.name.equals("Empty")) {
                    // remove the '>' at the end and replace with '/>'
                    start1.setCharAt(start1.length() - 1, '/');
                    start1.append(">");
                    start.append(start1.toString());
                    start1 = new StringBuffer();
                    tempStack.pop();
                    emptyNodeParent = true;
                    write_loop(nd, indent + 2);
                } else {
                    start.append(start1.toString());
                    start1 = new StringBuffer();
                    write_loop(nd, indent + 2);
                }
            }
            if ((!name.startsWith("(CHOICE)")) && 
                (!name.startsWith("(SEQUENCE)")) && (!name.equals("Empty"))
 //DFH               && !((name.indexOf("SEQUENCE")>-1)&&(((ni.getMinOcc().equals(ni.getMaxOcc())))))
                ) {
                if (textnode) {
                    if (!tempStack.isEmpty()) {
                        start.append((String)(tempStack.pop()));
                    }
                } else {
                    if (!emptyNodeParent) {
                        if (!tempStack.isEmpty()) {
                            start.append("\n" + indentString + 
                                (String)(tempStack.pop()));
                        }
                    } else {
                        emptyNodeParent = false;
                    }
                }
                textnode = false;
            }
        }
    }




	void SaveButton_actionPerformed(java.awt.event.ActionEvent event)
	{
	  TreePath tp = tree.getSelectionPath();
      if (tp != null) {
        Object ob = tp.getLastPathComponent();
        DefaultMutableTreeNode node = null;
        if (ob != null) {
          node = (DefaultMutableTreeNode)ob;
          writeXML(node, "SchemaOut.xml");
        }
	  }
	}
}
