/**
 *  '$RCSfile: TextImportWizard.java,v $'
 *  Copyright: 2000 Regents of the University of California and the
 *              National Center for Ecological Analysis and Synthesis
 *    Authors: @authors@
 *    Release: @release@
 *
 *   '$Author: higgins $'
 *     '$Date: 2002-02-21 22:10:26 $'
 * '$Revision: 1.27 $'
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package edu.ucsb.nceas.morpho.framework;

import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.table.*;
import java.io.*;
import java.net.*;
import java.util.Vector;
import java.util.StringTokenizer;
import java.util.Date;
import java.util.Enumeration;

import edu.ucsb.nceas.morpho.datapackage.wizard.PackageWizard;

/**
 * 'Text Import Wizard' is modeled after
 * the text import wizard in Excel. Its  purpose is to automatically 
 * create table entity and attribute metadata 
 * directly from a text based data file. It 'guesses' text-based tables column
 * data types (and delimiters) and checks for input validity
 
 * parses lines array based on assumed delimiters to determine data in each column
 * of the table. Table data is stored in a Vector of vectors. Outer vector is a
 * list of row vectors. Each row vector has a list of column data in String
 * format.
 * 
 */
public class TextImportWizard extends javax.swing.JFrame
{
  
  /**
   * flag indicating that multiple, sequential delimiters should be ignored
   * primarily useful with space delimiters
   */
  boolean ignoreConsequtiveDelimiters = false;
  
  /**
   * used as a flag to indicate whether 'blank' fields should be reported 
   * as errors; if false, they are not reported
   */
  boolean blankCheckFlag = false;
  
	/**
	 * number of lines in file
	 */
	int nlines;  

	/**
	 * array of line strings
	 */
	String[] lines; 
  String filename;
  
  /**
   * selected column variable
   */
  int selectedCol = -1;
  
  /**
   * flag used to avoid parsing everytime a checkbox is changed
   */
  boolean parseOn = true;
  
  /**
   * step number in wizard
   */
  int stepNumber = 1;
  
  /**
   * StringBuffer used to store results from various parts of the wizard
   */
  StringBuffer resultsBuffer;
  // indicates whether input is text
  boolean textFlag;
  
  // starting line
  int startingLine = 1;
  
  /**
   * flag indicating that labels for each column are contained in the
   * starting line of parsed data
   */
  boolean labelsInStartingLine = true;
  
	/**
	 * vector containing column Title strings
	 */
	// contains column titles
	Vector colTitles;

	/**
	 * vector containing ColumnData objects
	 */
	Vector colDataInfo;

	 	
	/**
	 * vector of vectors with table data
	 */
	Vector vec;
  
  /**
   * entity wizard
   */
  PackageWizard entityWizard = null;
  
  /**
   * attribute wizard
   */
  PackageWizard attributeWizard = null;

  /**
   * physical wizard
   */
  PackageWizard physicalWizard = null;
  
  private TextImportListener listener = null;
  
  boolean finishFlag = false;
  
  String delimiter = "";
  
	public TextImportWizard(String dataFileName, TextImportListener listener)
	{
    this.listener = listener;
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		setJMenuBar(JMenuBar1);
		setTitle("Text Import Wizard");
		setDefaultCloseOperation(javax.swing.JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout(0,0));
		setSize(695,486);
		setVisible(false);
		saveFileDialog.setMode(FileDialog.SAVE);
		saveFileDialog.setTitle("Save");
		//$$ saveFileDialog.move(24,336);
		openFileDialog.setMode(FileDialog.LOAD);
		openFileDialog.setTitle("Open");
		//$$ openFileDialog.move(0,336);
		JPanel2.setLayout(new FlowLayout(FlowLayout.LEFT,0,0));
		getContentPane().add(BorderLayout.NORTH, JPanel2);
		JToolBar1.setAlignmentY(0.222222F);
		JPanel2.add(JToolBar1);
		openButton.setText("Open Data File");
		openButton.setActionCommand("Open Data File");
		openButton.setDefaultCapable(false);
		openButton.setToolTipText("Open an existing document");
		openButton.setMnemonic((int)'O');
		JToolBar1.add(openButton);
		PasteDataButton.setText("Paste Data");
		PasteDataButton.setActionCommand("Paste Data");
		PasteDataButton.setDefaultCapable(false);
		PasteDataButton.setToolTipText("Click Here to Enter Data from Clipboard");
		JToolBar1.add(PasteDataButton);
		ShowResultsButton.setText("Show Results of Data Scan");
		ShowResultsButton.setActionCommand("Show Results");
		ShowResultsButton.setDefaultCapable(false);
		JToolBar1.add(ShowResultsButton);
		JPanel1.setLayout(new GridLayout(2,1,0,4));
		getContentPane().add(BorderLayout.CENTER, JPanel1);
		ControlsPanel.setLayout(new CardLayout(0,0));
		JPanel1.add(ControlsPanel);
		Step1ControlsPanel.setAlignmentY(0.0F);
		Step1ControlsPanel.setAlignmentX(0.0F);
		Step1ControlsPanel.setLayout(new GridLayout(7,1,0,0));
		ControlsPanel.add("card1", Step1ControlsPanel);
		JPanel17.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
		Step1ControlsPanel.add(JPanel17);
		JPanel6.setAlignmentY(0.473684F);
		JPanel6.setAlignmentX(0.0F);
		JPanel6.setLayout(new BoxLayout(JPanel6,BoxLayout.X_AXIS));
		Step1ControlsPanel.add(JPanel6);
		JLabel3.setText(" Table Name: ");
		JPanel6.add(JLabel3);
		JLabel3.setForeground(java.awt.Color.black);
		JLabel3.setFont(new Font("Dialog", Font.PLAIN, 12));
		JPanel6.add(TableNameTextField);
		JPanel7.setAlignmentY(0.473684F);
		JPanel7.setAlignmentX(0.0F);
		JPanel7.setLayout(new BoxLayout(JPanel7,BoxLayout.X_AXIS));
		Step1ControlsPanel.add(JPanel7);
		JLabel4.setText(" Description: ");
		JPanel7.add(JLabel4);
		JLabel4.setForeground(java.awt.Color.black);
		JLabel4.setFont(new Font("Dialog", Font.PLAIN, 12));
		JPanel7.add(TableDescriptionTextField);
		JPanel3.setAlignmentX(0.0F);
		JPanel3.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
		Step1ControlsPanel.add(JPanel3);
		JLabel1.setText("Choose the method used to separate fields on each line of your data");
		JLabel1.setAlignmentY(0.0F);
		JPanel3.add(JLabel1);
		JLabel1.setForeground(new java.awt.Color(102,102,153));
		JLabel1.setFont(new Font("Dialog", Font.PLAIN, 12));
		JPanel4.setAlignmentX(0.0F);
		JPanel4.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
		Step1ControlsPanel.add(JPanel4);
		DelimitedRadioButton.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
		DelimitedRadioButton.setText("Delimited  -  Characters such as tabs or commas separate each data field");
		DelimitedRadioButton.setActionCommand("Delimited  -  Characters such as tabs or commas separate each data field");
		DelimitedRadioButton.setAlignmentY(0.0F);
		DelimitedRadioButton.setSelected(true);
		JPanel4.add(DelimitedRadioButton);
		DelimitedRadioButton.setFont(new Font("Dialog", Font.PLAIN, 12));
		JPanel5.setAlignmentX(0.0F);
		JPanel5.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
		Step1ControlsPanel.add(JPanel5);
		FixedFieldRadioButton.setText("Fixed Width  -  Fields are aligned in columns with specified number of characters");
		FixedFieldRadioButton.setActionCommand("Fixed Width  -  Fields are aligned in columns with specified number of characters");
		FixedFieldRadioButton.setAlignmentY(0.0F);
		FixedFieldRadioButton.setEnabled(false);
		JPanel5.add(FixedFieldRadioButton);
		FixedFieldRadioButton.setFont(new Font("Dialog", Font.PLAIN, 12));
		StartingLinePanel.setAlignmentX(0.0F);
		StartingLinePanel.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
		Step1ControlsPanel.add(StartingLinePanel);
		JLabel2.setText("Start import at row: ");
		StartingLinePanel.add(JLabel2);
		JLabel2.setForeground(java.awt.Color.black);
		JLabel2.setFont(new Font("Dialog", Font.PLAIN, 12));
		StartingLineTextField.setText("1");
		StartingLineTextField.setColumns(4);
		StartingLinePanel.add(StartingLineTextField);
		JLabel7.setText("     ");
		StartingLinePanel.add(JLabel7);
		ColumnLabelsCheckBox.setText("Column Labels are in starting row");
		ColumnLabelsCheckBox.setActionCommand("Column Labels are in starting row");
		ColumnLabelsCheckBox.setSelected(true);
		StartingLinePanel.add(ColumnLabelsCheckBox);
		ColumnLabelsCheckBox.setFont(new Font("Dialog", Font.PLAIN, 12));
		Step2ControlsPanel.setLayout(new GridLayout(6,1,0,0));
		ControlsPanel.add("card2", Step2ControlsPanel);
		Step2ControlsPanel.setBackground(new java.awt.Color(204,204,204));
		Step2ControlsPanel.setVisible(false);
		JPanel8.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
		Step2ControlsPanel.add(JPanel8);
		JLabel5.setText("  ");
		JPanel8.add(JLabel5);
		JPanel9.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
		Step2ControlsPanel.add(JPanel9);
		JLabel8.setText("  Delimiters: ");
		JPanel9.add(JLabel8);
		JLabel8.setForeground(java.awt.Color.black);
		JLabel8.setFont(new Font("Dialog", Font.PLAIN, 12));
		TabCheckBox.setText("tab");
		TabCheckBox.setActionCommand("tab");
		TabCheckBox.setSelected(true);
		JPanel9.add(TabCheckBox);
		TabCheckBox.setFont(new Font("Dialog", Font.PLAIN, 12));
		CommaCheckBox.setText("comma");
		CommaCheckBox.setActionCommand("comma");
		JPanel9.add(CommaCheckBox);
		CommaCheckBox.setFont(new Font("Dialog", Font.PLAIN, 12));
		SpaceCheckBox.setText("space");
		SpaceCheckBox.setActionCommand("space");
		JPanel9.add(SpaceCheckBox);
		SpaceCheckBox.setFont(new Font("Dialog", Font.PLAIN, 12));
		SemicolonCheckBox.setText("semicolon");
		SemicolonCheckBox.setActionCommand("semicolon");
		JPanel9.add(SemicolonCheckBox);
		SemicolonCheckBox.setFont(new Font("Dialog", Font.PLAIN, 12));
		OtherCheckBox.setText("other");
		OtherCheckBox.setActionCommand("other");
		JPanel9.add(OtherCheckBox);
		OtherCheckBox.setFont(new Font("Dialog", Font.PLAIN, 12));
		OtherTextField.setColumns(2);
		JPanel9.add(OtherTextField);
		JPanel10.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
		Step2ControlsPanel.add(JPanel10);
		JPanel11.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
		Step2ControlsPanel.add(JPanel11);
		JPanel12.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
		Step2ControlsPanel.add(JPanel12);
		ConsecutiveCheckBox.setText("Treat consecutive delimiters as one");
		ConsecutiveCheckBox.setActionCommand("Treat consecutive delimiters as one");
		JPanel12.add(ConsecutiveCheckBox);
		ConsecutiveCheckBox.setFont(new Font("Dialog", Font.PLAIN, 12));
		Step3ControlsPanel.setLayout(new BorderLayout(0,0));
		ControlsPanel.add("card3", Step3ControlsPanel);
		Step3ControlsPanel.setVisible(false);
		JPanel13.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
		Step3ControlsPanel.add(BorderLayout.WEST, JPanel13);
		JPanel13.setBackground(java.awt.Color.white);
		JLabel6.setText("<html><br>Select column of<p>interest by \'clicking\'<p>on any cell in <p>column.<p>A red label indicates</p><p>a requiired item.</p>");
		JPanel13.add(JLabel6);
		JLabel6.setForeground(java.awt.Color.black);
		JPanel14.setAlignmentX(0.495413F);
		JPanel14.setLayout(new GridLayout(2,2,6,6));
		Step3ControlsPanel.add(BorderLayout.CENTER, JPanel14);
		JPanel19.setAlignmentX(0.495413F);
		JPanel19.setLayout(new BoxLayout(JPanel19,BoxLayout.Y_AXIS));
		JPanel14.add(JPanel19);
		JPanel21.setLayout(new FlowLayout(FlowLayout.LEFT,5,0));
		JPanel19.add(JPanel21);
		JLabel12.setText("Column Label:   ");
		JPanel21.add(JLabel12);
		JLabel12.setForeground(java.awt.Color.red);
		JLabel12.setFont(new Font("Dialog", Font.PLAIN, 12));
		ColumnLabelTextField.setColumns(12);
		JPanel21.add(ColumnLabelTextField);
		ColumnLabelTextField.setFont(new Font("Dialog", Font.PLAIN, 12));
		JPanel15.setLayout(new FlowLayout(FlowLayout.LEFT,5,0));
		JPanel19.add(JPanel15);
		JLabel9.setText("Column Name:  ");
		JPanel15.add(JLabel9);
		JLabel9.setForeground(java.awt.Color.red);
		JLabel9.setFont(new Font("Dialog", Font.PLAIN, 12));
		ColumnNameTextField.setColumns(12);
		JPanel15.add(ColumnNameTextField);
		ColumnNameTextField.setFont(new Font("Dialog", Font.PLAIN, 12));
		JPanel18.setLayout(new FlowLayout(FlowLayout.LEFT,5,0));
		JPanel19.add(JPanel18);
		JLabel11.setText("Column Unit:      ");
		JPanel18.add(JLabel11);
		JLabel11.setForeground(java.awt.Color.black);
		JLabel11.setFont(new Font("Dialog", Font.PLAIN, 12));
		ColumnUnitTextField.setColumns(12);
		JPanel18.add(ColumnUnitTextField);
		ColumnUnitTextField.setFont(new Font("Dialog", Font.PLAIN, 12));
		JPanel20.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
		JPanel19.add(JPanel20);
		JLabel15.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
		JLabel15.setText("Min:");
		JPanel20.add(JLabel15);
		JLabel15.setForeground(java.awt.Color.black);
		JLabel15.setFont(new Font("Dialog", Font.PLAIN, 12));
		MinTextField.setColumns(7);
		JPanel20.add(MinTextField);
		JLabel16.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
		JLabel16.setText("Max:");
		JPanel20.add(JLabel16);
		JLabel16.setForeground(java.awt.Color.black);
		JLabel16.setFont(new Font("Dialog", Font.PLAIN, 12));
		MaxTextField.setColumns(7);
		JPanel20.add(MaxTextField);
		JPanel23.setAlignmentX(0.0F);
		JPanel23.setLayout(new BorderLayout(0,0));
		JPanel14.add(JPanel23);
		JLabel13.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
		JLabel13.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
		JLabel13.setText("Column Definition:");
		JPanel23.add(BorderLayout.NORTH, JLabel13);
		JLabel13.setForeground(java.awt.Color.red);
		JLabel13.setFont(new Font("Dialog", Font.PLAIN, 12));
		JPanel23.add(BorderLayout.CENTER, JScrollPane2);
		ColumnDefTextArea.setLineWrap(true);
		ColumnDefTextArea.setWrapStyleWord(true);
		ColumnDefTextArea.setAlignmentX(0.0F);
		JScrollPane2.getViewport().add(ColumnDefTextArea);
		ColumnDefTextArea.setBounds(0,0,-90,15);
		JPanel16.setLayout(new BorderLayout(0,0));
		JPanel14.add(JPanel16);
		JLabel10.setText("Data Type:           ");
		JPanel16.add(BorderLayout.WEST, JLabel10);
		JLabel10.setForeground(java.awt.Color.black);
		JLabel10.setFont(new Font("Dialog", Font.PLAIN, 12));
		JScrollPane1.setOpaque(true);
		JPanel16.add(BorderLayout.CENTER, JScrollPane1);
		DataTypeList.setVisibleRowCount(4);
		JScrollPane1.getViewport().add(DataTypeList);
		DataTypeList.setBounds(0,0,0,0);
		JPanel24.setLayout(new BorderLayout(0,0));
		JPanel14.add(JPanel24);
		JPanel26.setLayout(new BorderLayout(0,0));
		JPanel24.add(BorderLayout.CENTER, JPanel26);
		JPanel26.add(BorderLayout.CENTER, UniqueItemsScroll);
		UniqueItemsScroll.getViewport().add(uniq);
		uniq.setBounds(0,0,-204,0);
		JPanel27.setLayout(new GridLayout(3,1,0,0));
		JPanel26.add(BorderLayout.WEST, JPanel27);
		JLabel14.setText("Unique Item List:");
		JPanel27.add(JLabel14);
		JLabel14.setForeground(java.awt.Color.black);
		JLabel14.setFont(new Font("Dialog", Font.PLAIN, 12));
		EnumCheckBox.setText("Use in Metadata");
		EnumCheckBox.setActionCommand("Use in Metadata");
		JPanel27.add(EnumCheckBox);
		EnumCheckBox.setFont(new Font("Dialog", Font.PLAIN, 12));
		JPanel25.setLayout(new GridLayout(2,1,0,0));
		JPanel24.add(BorderLayout.SOUTH, JPanel25);
		NumUniqueLabel.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
		NumUniqueLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		JPanel25.add(NumUniqueLabel);
		NumUniqueLabel.setForeground(java.awt.Color.black);
		NumUniqueLabel.setFont(new Font("Dialog", Font.PLAIN, 12));
		MinMaxLabel.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
		MinMaxLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		JPanel25.add(MinMaxLabel);
		MinMaxLabel.setForeground(java.awt.Color.black);
		MinMaxLabel.setFont(new Font("Dialog", Font.PLAIN, 12));
		((CardLayout) ControlsPanel.getLayout()).show(ControlsPanel,"card1");
		DataPanel.setLayout(new BorderLayout(0,0));
		JPanel1.add(DataPanel);
		DataPanel.add(BorderLayout.CENTER, DataScrollPanel);
		ButtonsPanel.setLayout(new FlowLayout(FlowLayout.RIGHT,5,5));
		getContentPane().add(BorderLayout.SOUTH, ButtonsPanel);
		StepNumberLabel.setText("Step #1 of 3");
		ButtonsPanel.add(StepNumberLabel);
		StepNumberLabel.setForeground(java.awt.Color.black);
		CancelButton.setText("Cancel");
		CancelButton.setActionCommand("Cancel");
		ButtonsPanel.add(CancelButton);
		BackButton.setText("< Back");
		BackButton.setActionCommand("< Back");
		BackButton.setEnabled(false);
		ButtonsPanel.add(BackButton);
		NextButton.setText("Next >");
		NextButton.setActionCommand("Next >");
		ButtonsPanel.add(NextButton);
		FinishButton.setText("Finish");
		FinishButton.setActionCommand("Finish");
		FinishButton.setEnabled(false);
		ButtonsPanel.add(FinishButton);
		//$$ JMenuBar1.move(168,312);
		fileMenu.setText("File");
		fileMenu.setActionCommand("File");
		fileMenu.setMnemonic((int)'F');
		JMenuBar1.add(fileMenu);
		openItem.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
		openItem.setText("Open...");
		openItem.setActionCommand("Open...");
		openItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.Event.CTRL_MASK));
		openItem.setMnemonic((int)'O');
		fileMenu.add(openItem);
		save_eml_table_entity.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
		save_eml_table_entity.setEnabled(false);
		save_eml_table_entity.setText(" Save Table Entity Information...");
		save_eml_table_entity.setActionCommand("Save");
		save_eml_table_entity.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.Event.CTRL_MASK));
		save_eml_table_entity.setMnemonic((int)'S');
		fileMenu.add(save_eml_table_entity);
		save_eml_attribute.setEnabled(false);
		save_eml_attribute.setText("Save Attribute Information...");
		save_eml_attribute.setActionCommand("Save As...");
		save_eml_attribute.setMnemonic((int)'A');
		fileMenu.add(save_eml_attribute);
		fileMenu.add(JSeparator1);
		exitItem.setText("Exit");
		exitItem.setActionCommand("Exit");
		exitItem.setMnemonic((int)'X');
		fileMenu.add(exitItem);
		DataTypeList.setSelectedIndex(0);
		//}}

		//{{INIT_MENUS
		//}}

		//{{REGISTER_LISTENERS
		SymWindow aSymWindow = new SymWindow();
		this.addWindowListener(aSymWindow);
		SymAction lSymAction = new SymAction();
		openItem.addActionListener(lSymAction);
		save_eml_table_entity.addActionListener(lSymAction);
		exitItem.addActionListener(lSymAction);
		openButton.addActionListener(lSymAction);
		NextButton.addActionListener(lSymAction);
		BackButton.addActionListener(lSymAction);
		FinishButton.addActionListener(lSymAction);
		ShowResultsButton.addActionListener(lSymAction);
		ColumnNameTextField.addActionListener(lSymAction);
		SymListSelection lSymListSelection = new SymListSelection();
		DataTypeList.addListSelectionListener(lSymListSelection);
		StartingLineTextField.addActionListener(lSymAction);
		SymFocus aSymFocus = new SymFocus();
		StartingLineTextField.addFocusListener(aSymFocus);
		SymItem lSymItem = new SymItem();
		ColumnLabelsCheckBox.addItemListener(lSymItem);
		TabCheckBox.addItemListener(lSymItem);
		CommaCheckBox.addItemListener(lSymItem);
		SpaceCheckBox.addItemListener(lSymItem);
		SemicolonCheckBox.addItemListener(lSymItem);
		OtherCheckBox.addItemListener(lSymItem);
		PasteDataButton.addActionListener(lSymAction);
		ColumnUnitTextField.addActionListener(lSymAction);
		save_eml_attribute.addActionListener(lSymAction);
		CancelButton.addActionListener(lSymAction);
		ColumnLabelTextField.addActionListener(lSymAction);
		ColumnDefTextArea.addFocusListener(aSymFocus);
		ColumnNameTextField.addFocusListener(aSymFocus);
		ColumnLabelTextField.addFocusListener(aSymFocus);
		ColumnUnitTextField.addFocusListener(aSymFocus);
		EnumCheckBox.addItemListener(lSymItem);
		MinTextField.addActionListener(lSymAction);
		MinTextField.addFocusListener(aSymFocus);
		MaxTextField.addActionListener(lSymAction);
		MaxTextField.addFocusListener(aSymFocus);
		uniq.addFocusListener(aSymFocus);
		//}}
		
		resultsBuffer = new StringBuffer();
		String[] dataTypes = {"Text", "Integers", "Floating Point", "Date", "Enumeration", "Codes", "skip this column" };

		DataTypeList.setListData(dataTypes);
    
    //assign the filename and get the wizard started.
    if(dataFileName != null)
    {
      File ff = new File(dataFileName);
      TableNameTextField.setText(ff.getName());
      filename = dataFileName;
      parsefile(filename);
      createLinesTable();
      resultsBuffer = new StringBuffer();
      stepNumber = 1;
      StepNumberLabel.setText("Step #"+stepNumber+" of 3");
      CardLayout cl = (CardLayout)ControlsPanel.getLayout();
      cl.show(ControlsPanel, "card"+stepNumber);
      BackButton.setEnabled(false);
      FinishButton.setEnabled(false);
      NextButton.setEnabled(true);
    }
	}

    /**
     * Creates a new instance of JFrame1 with the given title.
     * @param sTitle the title for the new frame.
     * @see #JFrame1()
     */
/*	public TextImportWizard(String sTitle)
	{
		this();
		setTitle(sTitle);
	}
	*/
	
	/**
	 * reference to a packagewizard
	 * used to pass a fixed XML string to a PackageWizard
	 */
	public void setEntityWizard(PackageWizard entity) {
	  this.entityWizard = entity;
	}

	/**
	 * reference to a packagewizard
	 * used to pass a fixed XML string to a PackageWizard
	 */
	public void setAttributeWizard(PackageWizard attribute) {
	  this.attributeWizard = attribute;
	}

	/**
	 * reference to a packagewizard
	 * used to pass a fixed XML string to a PackageWizard
	 */
	public void setPhysicalWizard(PackageWizard physical) {
	  this.physicalWizard = physical;
	}
	
	
	/**
	 * The entry point for this application.
	 * Sets the Look and Feel to the System Look and Feel.
	 * Creates a new JFrame1 and makes it visible.
	 */
	/*static public void main(String args[])
	{
		try {
		    // Add the following code if you want the Look and Feel
		    // to be set to the Look and Feel of the native system.
		    
		    try {
		        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		    } 
		    catch (Exception e) { 
		    }
		    

			//Create a new instance of our application's frame, and make it visible.
			(new TextImportWizard(args[0])).setVisible(true);
		} 
		catch (Throwable t) {
			t.printStackTrace();
			//Ensure the application exits with an error condition.
			System.exit(1);
		}
	}*/

    /**
     * Notifies this component that it has been added to a container
     * This method should be called by <code>Container.add</code>, and 
     * not by user code directly.
     * Overridden here to adjust the size of the frame if needed.
     * @see java.awt.Container#removeNotify
     */
	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension size = getSize();
		
		super.addNotify();
		
		if (frameSizeAdjusted)
			return;
		frameSizeAdjusted = true;
		
		// Adjust size of frame according to the insets and menu bar
		javax.swing.JMenuBar menuBar = getRootPane().getJMenuBar();
		int menuBarHeight = 0;
		if (menuBar != null)
		    menuBarHeight = menuBar.getPreferredSize().height;
		Insets insets = getInsets();
		setSize(insets.left + insets.right + size.width, insets.top + insets.bottom + size.height + menuBarHeight);
	}

	// Used by addNotify
	boolean frameSizeAdjusted = false;

	//{{DECLARE_CONTROLS
	java.awt.FileDialog saveFileDialog = new java.awt.FileDialog(this);
	java.awt.FileDialog openFileDialog = new java.awt.FileDialog(this);
	javax.swing.JPanel JPanel2 = new javax.swing.JPanel();
	javax.swing.JToolBar JToolBar1 = new javax.swing.JToolBar();
	javax.swing.JButton openButton = new javax.swing.JButton();
	javax.swing.JButton PasteDataButton = new javax.swing.JButton();
	javax.swing.JButton ShowResultsButton = new javax.swing.JButton();
	javax.swing.JPanel JPanel1 = new javax.swing.JPanel();
	javax.swing.JPanel ControlsPanel = new javax.swing.JPanel();
	javax.swing.JPanel Step1ControlsPanel = new javax.swing.JPanel();
	javax.swing.JPanel JPanel17 = new javax.swing.JPanel();
	javax.swing.JPanel JPanel6 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel3 = new javax.swing.JLabel();
	javax.swing.JTextField TableNameTextField = new javax.swing.JTextField();
	javax.swing.JPanel JPanel7 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel4 = new javax.swing.JLabel();
	javax.swing.JTextField TableDescriptionTextField = new javax.swing.JTextField();
	javax.swing.JPanel JPanel3 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel1 = new javax.swing.JLabel();
	javax.swing.JPanel JPanel4 = new javax.swing.JPanel();
	javax.swing.JRadioButton DelimitedRadioButton = new javax.swing.JRadioButton();
	javax.swing.JPanel JPanel5 = new javax.swing.JPanel();
	javax.swing.JRadioButton FixedFieldRadioButton = new javax.swing.JRadioButton();
	javax.swing.JPanel StartingLinePanel = new javax.swing.JPanel();
	javax.swing.JLabel JLabel2 = new javax.swing.JLabel();
	javax.swing.JTextField StartingLineTextField = new javax.swing.JTextField();
	javax.swing.JLabel JLabel7 = new javax.swing.JLabel();
	javax.swing.JCheckBox ColumnLabelsCheckBox = new javax.swing.JCheckBox();
	javax.swing.JPanel Step2ControlsPanel = new javax.swing.JPanel();
	javax.swing.JPanel JPanel8 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel5 = new javax.swing.JLabel();
	javax.swing.JPanel JPanel9 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel8 = new javax.swing.JLabel();
	javax.swing.JCheckBox TabCheckBox = new javax.swing.JCheckBox();
	javax.swing.JCheckBox CommaCheckBox = new javax.swing.JCheckBox();
	javax.swing.JCheckBox SpaceCheckBox = new javax.swing.JCheckBox();
	javax.swing.JCheckBox SemicolonCheckBox = new javax.swing.JCheckBox();
	javax.swing.JCheckBox OtherCheckBox = new javax.swing.JCheckBox();
	javax.swing.JTextField OtherTextField = new javax.swing.JTextField();
	javax.swing.JPanel JPanel10 = new javax.swing.JPanel();
	javax.swing.JPanel JPanel11 = new javax.swing.JPanel();
	javax.swing.JPanel JPanel12 = new javax.swing.JPanel();
	javax.swing.JCheckBox ConsecutiveCheckBox = new javax.swing.JCheckBox();
	javax.swing.JPanel Step3ControlsPanel = new javax.swing.JPanel();
	javax.swing.JPanel JPanel13 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel6 = new javax.swing.JLabel();
	javax.swing.JPanel JPanel14 = new javax.swing.JPanel();
	javax.swing.JPanel JPanel19 = new javax.swing.JPanel();
	javax.swing.JPanel JPanel21 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel12 = new javax.swing.JLabel();
	javax.swing.JTextField ColumnLabelTextField = new javax.swing.JTextField();
	javax.swing.JPanel JPanel15 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel9 = new javax.swing.JLabel();
	javax.swing.JTextField ColumnNameTextField = new javax.swing.JTextField();
	javax.swing.JPanel JPanel18 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel11 = new javax.swing.JLabel();
	javax.swing.JTextField ColumnUnitTextField = new javax.swing.JTextField();
	javax.swing.JPanel JPanel20 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel15 = new javax.swing.JLabel();
	javax.swing.JTextField MinTextField = new javax.swing.JTextField();
	javax.swing.JLabel JLabel16 = new javax.swing.JLabel();
	javax.swing.JTextField MaxTextField = new javax.swing.JTextField();
	javax.swing.JPanel JPanel23 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel13 = new javax.swing.JLabel();
	javax.swing.JScrollPane JScrollPane2 = new javax.swing.JScrollPane();
	javax.swing.JTextArea ColumnDefTextArea = new javax.swing.JTextArea();
	javax.swing.JPanel JPanel16 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel10 = new javax.swing.JLabel();
	javax.swing.JScrollPane JScrollPane1 = new javax.swing.JScrollPane();
	javax.swing.JList DataTypeList = new javax.swing.JList();
	javax.swing.JPanel JPanel24 = new javax.swing.JPanel();
	javax.swing.JPanel JPanel26 = new javax.swing.JPanel();
	javax.swing.JScrollPane UniqueItemsScroll = new javax.swing.JScrollPane();
	javax.swing.JTable uniq = new javax.swing.JTable();
	javax.swing.JPanel JPanel27 = new javax.swing.JPanel();
	javax.swing.JLabel JLabel14 = new javax.swing.JLabel();
	javax.swing.JCheckBox EnumCheckBox = new javax.swing.JCheckBox();
	javax.swing.JPanel JPanel25 = new javax.swing.JPanel();
	javax.swing.JLabel NumUniqueLabel = new javax.swing.JLabel();
	javax.swing.JLabel MinMaxLabel = new javax.swing.JLabel();
	javax.swing.JPanel DataPanel = new javax.swing.JPanel();
	javax.swing.JScrollPane DataScrollPanel = new javax.swing.JScrollPane();
	javax.swing.JPanel ButtonsPanel = new javax.swing.JPanel();
	javax.swing.JLabel StepNumberLabel = new javax.swing.JLabel();
	javax.swing.JButton CancelButton = new javax.swing.JButton();
	javax.swing.JButton BackButton = new javax.swing.JButton();
	javax.swing.JButton NextButton = new javax.swing.JButton();
	javax.swing.JButton FinishButton = new javax.swing.JButton();
	javax.swing.JMenuBar JMenuBar1 = new javax.swing.JMenuBar();
	javax.swing.JMenu fileMenu = new javax.swing.JMenu();
	javax.swing.JMenuItem openItem = new javax.swing.JMenuItem();
	javax.swing.JMenuItem save_eml_table_entity = new javax.swing.JMenuItem();
	javax.swing.JMenuItem save_eml_attribute = new javax.swing.JMenuItem();
	javax.swing.JSeparator JSeparator1 = new javax.swing.JSeparator();
	javax.swing.JMenuItem exitItem = new javax.swing.JMenuItem();
	//}}

	//{{DECLARE_MENUS
	//}}

	void exitApplication()
	{
	  // passes string version of XML docs created by TextImportWizard
	  // to a package wizard
	  
	  this.setVisible(false);
	  this.dispose();
/*		try {
	    	// Beep
	    	Toolkit.getDefaultToolkit().beep();
	    	// Show a confirmation dialog
	    	int reply = JOptionPane.showConfirmDialog(this, 
	    	                                          "Do you really want to exit?", 
	    	                                          "JFC Application - Exit" , 
	    	                                          JOptionPane.YES_NO_OPTION, 
	    	                                          JOptionPane.QUESTION_MESSAGE);
			// If the confirmation was affirmative, handle exiting.
			if (reply == JOptionPane.YES_OPTION)
			{
*/
 //         this.setVisible(false);    // hide the Frame//	    	this.dispose();            // free the system resources
//		    	System.exit(0);            // close the application
//			}
//		} catch (Exception e) {
//		}
	}

	class SymWindow extends java.awt.event.WindowAdapter
	{
		public void windowClosing(java.awt.event.WindowEvent event)
		{
			Object object = event.getSource();
			if (object == TextImportWizard.this)
				TextImportWizard_windowClosing(event);
		}
	}

	void TextImportWizard_windowClosing(java.awt.event.WindowEvent event)
	{
		// to do: code goes here.
			 
		TextImportWizard_windowClosing_Interaction1(event);
	}

	void TextImportWizard_windowClosing_Interaction1(java.awt.event.WindowEvent event) {
		try {
			this.exitApplication();
		} catch (Exception e) {
		}
	}

	class SymAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			if (object == openItem)
				openItem_actionPerformed(event);
			else if (object == save_eml_table_entity)
				save_eml_table_entity_actionPerformed(event);
			else if (object == exitItem)
				exitItem_actionPerformed(event);
			if (object == openButton)
				openButton_actionPerformed(event);
			if (object == NextButton)
				NextButton_actionPerformed(event);
			else if (object == BackButton)
				BackButton_actionPerformed(event);
			else if (object == FinishButton)
				FinishButton_actionPerformed(event);
			if (object == ShowResultsButton)
				ShowResultsButton_actionPerformed(event);
			else if (object == ColumnNameTextField)
				ColumnNameTextField_actionPerformed(event);
			else if (object == StartingLineTextField)
				StartingLineTextField_actionPerformed(event);
			else if (object == PasteDataButton)
				PasteDataButton_actionPerformed(event);
			else if (object == ColumnUnitTextField)
				ColumnUnitTextField_actionPerformed(event);
			else if (object == save_eml_attribute)
				saveEmlAttribute_actionPerformed(event);
			else if (object == CancelButton)
				CancelButton_actionPerformed(event);
			else if (object == ColumnLabelTextField)
				ColumnLabelTextField_actionPerformed(event);
			else if (object == MinTextField)
				MinTextField_actionPerformed(event);
			else if (object == MaxTextField)
				MaxTextField_actionPerformed(event);
		}
	}

	/**
	 * return most frequent number of occurances of indicated substring
	 * 
	 * @param event
	 */
	void openItem_actionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.
			 
		openItem_actionPerformed_Interaction1(event);
	}

	/**
	 * reads input data file and creates a table of 'lines'
	 * 
	 * @param event
	 */
	void openItem_actionPerformed_Interaction1(java.awt.event.ActionEvent event) {
		try {
			// openFileDialog Show the FileDialog
			openFileDialog.setVisible(true);
			String file = openFileDialog.getFile();
			if (file!=null) {
			  file = openFileDialog.getDirectory()+file;
			  filename = file;
			  startImport(file);
/*        TableNameTextField.setText(filename);
        parsefile(file);
        createLinesTable();
		    resultsBuffer = new StringBuffer();
		    stepNumber = 1;
		    StepNumberLabel.setText("Step # "+stepNumber);
		    CardLayout cl = (CardLayout)ControlsPanel.getLayout();
		    cl.show(ControlsPanel, "card"+stepNumber);
		    BackButton.setEnabled(false);
		    FinishButton.setEnabled(false);
		    NextButton.setEnabled(true);
 */
			}
		} catch (Exception e) {
		}
	}

public void startImport(String file) {
        TableNameTextField.setText(file);
        parsefile(file);
        createLinesTable();
		    resultsBuffer = new StringBuffer();
		    stepNumber = 1;
		    StepNumberLabel.setText("Step #"+stepNumber+" of 3");
		    CardLayout cl = (CardLayout)ControlsPanel.getLayout();
		    cl.show(ControlsPanel, "card"+stepNumber);
		    BackButton.setEnabled(false);
		    FinishButton.setEnabled(false);
		    NextButton.setEnabled(true);
}




  /**
   * creates a JTable based on lines in input
   */
  void createLinesTable() {
        Vector vec = new Vector();
        for (int i=0;i<nlines;i++) {
          Vector vec1 = new Vector();
          vec1.addElement(new String().valueOf(i+1));
          vec1.addElement(lines[i]);
          vec.addElement(vec1);
        }
        Vector title = new Vector();
        title.addElement("#");
        title.addElement("Lines in "+filename);
        JTable table = new JTable(vec, title);
		    table.setFont(new Font("MonoSpaced", Font.PLAIN, 14));
		    TableColumn column = null;
		    column = table.getColumnModel().getColumn(0);
		    column.setPreferredWidth(40);
		    column.setMaxWidth(40);
        DataScrollPanel.getViewport().add(table);
    
  }

	void save_eml_table_entity_actionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.
			 
		save_eml_table_entity_actionPerformed_Interaction1(event);
	}

	void save_eml_table_entity_actionPerformed_Interaction1(java.awt.event.ActionEvent event) {
		try {
			// saveFileDialog Show the FileDialog
			saveFileDialog.setFile("table_entity.xml");
			saveFileDialog.setVisible(true);
		String filepath = saveFileDialog.getDirectory()+saveFileDialog.getFile();
		System.out.println(filepath);
		String table_entityString = createXMLEntityString();
		StringReader in = new StringReader(table_entityString);
		FileWriter out = new FileWriter(filepath);
        int c;

        while ((c = in.read()) != -1)
           out.write(c);

        in.close();
        out.close();
		} catch (Exception e) {}
	}
 
	void exitItem_actionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.
			 
		exitItem_actionPerformed_Interaction1(event);
	}

	void exitItem_actionPerformed_Interaction1(java.awt.event.ActionEvent event) {
		try {
			this.exitApplication();
		} catch (Exception e) {
		}
	}

	void openButton_actionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.
			 
		openButton_actionPerformed_Interaction1(event);
	}

	/**
	 * reads input data file and creates a table of 'lines'
	 * 
	 * @param event
	 */
	void openButton_actionPerformed_Interaction1(java.awt.event.ActionEvent event) {
		try {
			// openFileDialog Show the FileDialog
			openFileDialog.setVisible(true);
			String file = openFileDialog.getFile();
			if (file!=null) {
			  file = openFileDialog.getDirectory()+file;
			  filename = file;
        TableNameTextField.setText(filename);
        parsefile(file);
        createLinesTable();
		      resultsBuffer = new StringBuffer();
		      stepNumber = 1;
		      StepNumberLabel.setText("Step #"+stepNumber+" of 3");
		      CardLayout cl = (CardLayout)ControlsPanel.getLayout();
		      cl.show(ControlsPanel, "card"+stepNumber);
		      BackButton.setEnabled(false);
		      FinishButton.setEnabled(false);
		      NextButton.setEnabled(true);
			}
		} catch (Exception e) {
		}
	}
	
    /**
     * parses data input file into an array of lines (Strings)
     * 
     * @param f the file name
     */
    private void parsefile (String f) {
      int i;
      int pos;
      String temp, temp1;
        
      if (isTextFile(f)) {
        resultsBuffer = new StringBuffer("");
        resultsBuffer.append(f+" is apparently a text file\n");
        textFlag = true;
        try {
        BufferedReader in = new BufferedReader(new FileReader(f));
        nlines = 0;
        try {
            while ((temp = in.readLine())!=null) {
                if (temp.length()>0) {   // do not count blank lines
                nlines++;} 
                if (nlines>10000) {
                  JOptionPane.showMessageDialog(this, "Data File parsing has been truncated at 10000 lines due to large size!",
                        "Message",JOptionPane.INFORMATION_MESSAGE, null);
                  break;
                }
            }
            in.close();
        }
        catch (IOException e) {};
        }
        catch (IOException e) {};
        lines = new String[nlines];
        // now read again since we know how many lines
        try {
        BufferedReader in1 = new BufferedReader(new FileReader(f));
        try {
            for (i=0;i<nlines;i++) {
                temp = in1.readLine();
                while (temp.length()==0) {temp=in1.readLine();}
                lines[i] = temp + "\n";
            }
            in1.close();
        }
        catch (IOException e) {};
        }
        catch (IOException e) {};
        resultsBuffer.append("Number of lines: "+nlines+"\n");
        resultsBuffer.append("Most probable delimiter is "+guessDelimiter()+"\n");
      }
      else {
        resultsBuffer = new StringBuffer("");
        resultsBuffer.append(f+" is NOT a text file\n");
        textFlag = false;
        JOptionPane.showMessageDialog(this, "Selected File is NOT a text file!",
           "Message",JOptionPane.INFORMATION_MESSAGE, null);
        
      }
    }            
    /**
     * parses data input string into an array of lines (Strings)
     * 
     * @param s input string
     */

    private void parseString (String s) {
        int i;
        int pos;
        String temp, temp1;
          BufferedReader in = new BufferedReader(new StringReader(s));
          nlines = 0;
          try {
            while ((temp = in.readLine())!=null) {
                if (temp.length()>0) {   // do not count blank lines
                nlines++;} 
            }
            in.close();
          }
        catch (Exception e) {};
        lines = new String[nlines];
          // now read again since we know how many lines
          BufferedReader in1 = new BufferedReader(new StringReader(s));
          try {
            for (i=0;i<nlines;i++) {
                temp = in1.readLine();
                while (temp.length()==0) {temp=in1.readLine();}
                lines[i] = temp + "\n";

            }
            in1.close();
          }
          catch (Exception e) {};
        resultsBuffer = new StringBuffer("");
        resultsBuffer.append("Number of lines: "+nlines+"\n");
        resultsBuffer.append("Most probable delimiter is "+guessDelimiter()+"\n");
    }            
	
	private void parseDelimited() {
	  if (lines!=null) {
	    int start = startingLine;  // startingLine is 1-based not 0-based
	    if (labelsInStartingLine) {
	      colTitles = getColumnValues(lines[startingLine-1]);
	    }
	    else {
	      colTitles = getColumnValues(lines[startingLine-1]);  // use just to get # of cols
	      int temp = colTitles.size();
	      colTitles = new Vector();
	      for (int l=0;l<temp;l++) {
	        colTitles.addElement("Column "+(l+1));  
	      }
	      start--;  // include first line
	    }
	    vec = new Vector();
	    Vector vec1 = new Vector();
	    int numcols = colTitles.size();
	    resultsBuffer.append("Number of columns assumed: "+numcols+"\n");
	    for (int i=start;i<nlines;i++) {
	      vec1 = getColumnValues(lines[i]);
	      boolean missing = false;
	      while (vec1.size()<numcols) {
	        vec1.addElement("");
	        missing = true;
	      }
	      if (missing) {
	        resultsBuffer.append("Insufficient number of items in row "+(i+1)+"\n"+" Empty strings added!"+"\n"+"\n"); 
	      }
	      vec.addElement(vec1);
	    }
	  
	    buildTable(colTitles, vec);
	    colDataInfo = new Vector();   // vector of ColumnData objects
	    for (int k=0;k<numcols;k++) {
	      ColumnData cd = new ColumnData(k);
	      colDataInfo.addElement(cd);
	      cd.colType = guessColFormat(k);
	      cd.colTitle = (String)colTitles.elementAt(k);
	      cd.colName = (String)colTitles.elementAt(k);
	      Vector lst = getUniqueColValues(k);
	      cd.colUniqueItemsList = lst;
	      cd.colUniqueItemsDefs = lst;
	      cd.colNumUniqueItems = lst.size();
	    }
    }
	}
	
	/**
	 * builds JTable from input data ans includes event code for handling clicks on
	 * table (e.g. column selection)
	 * 
	 * @param cTitles
	 * @param data
	 */
	private void buildTable(Vector cTitles, Vector data) {
      final JTable table = new JTable(vec, colTitles);
      table.setColumnSelectionAllowed(true);
      table.setRowSelectionAllowed(false);
      table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
      
      ListSelectionModel colSM = table.getColumnModel().getSelectionModel();
          colSM.addListSelectionListener(new ListSelectionListener() {
              public void valueChanged(ListSelectionEvent e) {
                  //Ignore extra messages.
                  if (e.getValueIsAdjusting()) return;
                  
                  ListSelectionModel lsm =
                      (ListSelectionModel)e.getSource();
                  if (lsm.isSelectionEmpty()) {
                      //no columns are selected
                  } else {
                      selectedCol = lsm.getMinSelectionIndex();
                      //selectedCol is selected
                      ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);
                      EnumCheckBox.setSelected(cd.useEnumerationList);
                      int numUnique =  cd.colNumUniqueItems;
                      String str = "There are "+numUnique+" unique item(s) in this column";
                      NumUniqueLabel.setText(str);
                      if (cd.colType.equals("Floating Point")) {
                        String dmin = Double.toString(cd.colMin);
                        String dmax = Double.toString(cd.colMax);
                        String daver = Double.toString(cd.colAverage);
                        MinMaxLabel.setText("Min:"+ dmin +"  Max:" + dmax + "  Aver:" +daver);
                        MinTextField.setText(dmin);
                        MaxTextField.setText(dmax);
                      } 
                      else if ((cd.colType.equals("Integers"))) {
                        String min = Integer.toString((int)cd.colMin);
                        String max = Integer.toString((int)cd.colMax);
                        String aver = Double.toString(cd.colAverage);
                        MinMaxLabel.setText("Min:"+ min +"  Max:" + max + "  Aver:" +aver);   
                        MinTextField.setText(min);
                        MaxTextField.setText(max);
                     }
                      else {
                        MinMaxLabel.setText("");
                        MinTextField.setText("");
                        MaxTextField.setText("");
                      }
                      String[] headers = new String[2];
                      headers[0] = "Code";
                      headers[1] = "Definition";
                      DefaultTableModel dtm = new DefaultTableModel(headers,0);
                      String[] row = new String[2];
                      for (int j=0;j<cd.colUniqueItemsList.size();j++) {
                        row[0] = (String)cd.colUniqueItemsList.elementAt(j);
                        row[1] = (String)cd.colUniqueItemsDefs.elementAt(j);
                        dtm.addRow(row);
                      }
                      for (int i=0;i<20;i++) {
                        row[0] = "";
                        row[1] = "";
                        dtm.addRow(row);
                      }
                      
            //          JList uniq = new JList(cd.colUniqueItemsList);
            //          JTable uniq = new JTable(dtm);
                      uniq.setModel(dtm);
                      UniqueItemsScroll.getViewport().removeAll();
                      UniqueItemsScroll.getViewport().add(uniq);
                      ColumnUnitTextField.setText(cd.colUnits);
                      ColumnNameTextField.setText(cd.colName);
                      ColumnLabelTextField.setText(cd.colTitle);
                      String colType = cd.colType;
                      DataTypeList.setSelectedValue(colType, true);
                      ColumnDefTextArea.setText(cd.colDefinition);
                     
                  }
              }
          });
      
      DataScrollPanel.getViewport().removeAll();
      DataScrollPanel.getViewport().add(table);
	}

	/**
	 * parses a line of text data into a Vector of column data for that row
	 * 
	 * @param str a line of string data from input
	 * @return a vector with each elements being column data for the row
	 */
	private Vector getColumnValues(String str) {
	    String sDelim = getDelimiterString();
	    String oldToken = "";
	    String token = "";
	    Vector res = new Vector();
	    ignoreConsequtiveDelimiters = ConsecutiveCheckBox.isSelected();
	    if (ignoreConsequtiveDelimiters) {
	      StringTokenizer st = new StringTokenizer(str, sDelim, false);
	      while( st.hasMoreTokens() ) {
	        token = st.nextToken().trim();
	        res.addElement(token);
	      }
	    }
	    else {
	      StringTokenizer st = new StringTokenizer(str, sDelim, true);
	      while( st.hasMoreTokens() ) {
	        token = st.nextToken().trim();
	        if (!inDelimiterList(token, sDelim)) {
	            res.addElement(token);
	        }
	        else {
	            if ((inDelimiterList(oldToken,sDelim))&&(inDelimiterList(token,sDelim))) {
	                res.addElement("");
                }
	        }
	        oldToken = token;
	      }
	    }
	    return res;
	}
	
	private String getDelimiterString() {
	  String str = "";
	  if (TabCheckBox.isSelected()) str = str+"\t";
	  if (CommaCheckBox.isSelected()) str = str + ",";
	  if (SpaceCheckBox.isSelected()) str = str + " ";
	  if (SemicolonCheckBox.isSelected()) str = str +";";
	  if (OtherCheckBox.isSelected()) {
	    String temp = OtherTextField.getText();
	    if (temp.length()>0) {
	      temp = temp.substring(0,1);
	      str = str + temp;
	    }
	  }
	  return str;
	}

	private String getDelimiterStringAsText() {
	  String str = "";
	  if (TabCheckBox.isSelected()) str = str+"#x09";
	  if (CommaCheckBox.isSelected()) str = str + ",";
	  if (SpaceCheckBox.isSelected()) str = str + "#x20";
	  if (SemicolonCheckBox.isSelected()) str = str +";";
	  if (OtherCheckBox.isSelected()) {
	    String temp = OtherTextField.getText();
	    if (temp.length()>0) {
	      temp = temp.substring(0,1);
	      str = str + temp;
	    }
	  }
	  return str;
	}
	
	
	private boolean inDelimiterList(String token, String delim) {
	    boolean result = false;
	    int test = delim.indexOf(token);
	    if (test>-1) {
	        result = true;
	    }
	    else { result = false; }
	    return result;
	}
	



	void NextButton_actionPerformed(java.awt.event.ActionEvent event)
	{
		stepNumber++;
		if (stepNumber==3) FinishButton.setEnabled(true);
	  if (stepNumber<3) {
		  BackButton.setEnabled(true);
		}
		else {
		  NextButton.setEnabled(false);
		}
		StepNumberLabel.setText("Step #"+stepNumber+" of 3");
		CardLayout cl = (CardLayout)ControlsPanel.getLayout();
		cl.show(ControlsPanel, "card"+stepNumber);
		if (stepNumber == 2) parseDelimited();
	}

	void BackButton_actionPerformed(java.awt.event.ActionEvent event)
	{
		stepNumber--;
		if (stepNumber<3) FinishButton.setEnabled(false);
		if (stepNumber>1) {
		  NextButton.setEnabled(true);
		}
		else {
		  BackButton.setEnabled(false); 
		}
		StepNumberLabel.setText("Step #"+stepNumber+" of 3");
		CardLayout cl = (CardLayout)ControlsPanel.getLayout();
		cl.show(ControlsPanel, "card"+stepNumber);
		if (stepNumber==1) {
		  if (lines!=null) {
		    createLinesTable(); 
		  }
		}
	}

	void FinishButton_actionPerformed(java.awt.event.ActionEvent event)
	{
	String info = checkForBlankInfo();
	// info should be null if all fields are not blank
	if (info!=null) {
        int  choice = JOptionPane.showConfirmDialog(null, 
                             "This package may be invalid because certain " + 
                             "fields in columns \n"+info+"\n contain no information. \n " +
                             "To correct this, please press Cancel or No\n" +
                             "and then select each column in the table\n" +
                             "and enter the appropriate information.\n\n"+
                             "Are you sure you want to save now?", 
                             "Invalid Document", 
                             JOptionPane.YES_NO_CANCEL_OPTION,
                             JOptionPane.WARNING_MESSAGE);
      if((choice == JOptionPane.CANCEL_OPTION)||(choice == JOptionPane.NO_OPTION)) {
        return;  
      }
	}
	    
    if (entityWizard!=null) {
      //System.out.println("===============creating xml string: " + createXMLEntityString());
	    entityWizard.setXMLString(createXMLEntityString());
	  }
	  if (attributeWizard!=null) {
	    attributeWizard.setXMLString(createXMLAttributeString());
      //System.out.println("===============creating xml string: " + createXMLAttributeString());
	  }
	  if (physicalWizard!=null) {
	    physicalWizard.setXMLString(createXMLPhysicalString());
	  }
    
	  for (int i=0;i<colTitles.size();i++) {
	    checkColumnInfo(i);
	  }
	  
//	  resultsBuffer.append("\n");
//	  resultsBuffer.append(createXMLEntityString());
//	  resultsBuffer.append("\n\n");
//	  resultsBuffer.append(createXMLAttributeString());
	  
	  save_eml_table_entity.setEnabled(true);
	  save_eml_attribute.setEnabled(true);
	  String tempS = "Click on 'Show Results' button to see results, including XML files.";
	  if (entityWizard!=null) {
	    tempS = tempS + " Information will automatically be added to the Data Package under construction.";
	  }
	  else {
	    tempS = tempS + " Also, see File Menu to Save Files.";
	  }
    //JOptionPane.showMessageDialog(this, tempS,
    //"Message",JOptionPane.INFORMATION_MESSAGE, null);
    //----------
/*		try {
			// ResultsFrame Create and show the ResultsFrame
			TextImportResultsFrame rf = new TextImportResultsFrame();
			rf.ResultsTextArea.setText(resultsBuffer.toString());
			rf.setVisible(true);
		} catch (java.lang.Exception e) {
		}
*/    //----------
	  finishFlag = true;
    if(listener != null)
    {
      listener.importComplete();
    }
    this.dispose();
	}
 
  void PasteDataButton_actionPerformed(java.awt.event.ActionEvent event)
 {
   String s = "";
    Clipboard cb = Toolkit.getDefaultToolkit().getSystemClipboard();
    Transferable content = cb.getContents(this);
    try {
      s =(String)content.getTransferData(DataFlavor.stringFlavor);
      System.out.println(s);
    }
    catch (Throwable exc) {
      System.err.println("Clipboard Problem!");
    }

    TableNameTextField.setText("Data from Clipboard");
    parseString(s);
    createLinesTable();
  }


 
 /*-----------------------------------
  * routines for trying to guess the delimiter being used
  *
  */
  
  /* returns the number of occurances of a substring in specified input string 
   * inS is input string
   * subS is substring
  */
  private int charCount(String inS, String subS ) {
    int cnt = -1;
    int pos = 0;
    int pos1 = 0;
    while (pos > -1) {
      pos1=inS.indexOf(subS, pos+1);
      pos = pos1;
      cnt++; 
    }
    if (cnt<0) cnt = 0;
    return cnt;
  }
  
   /**
    * return most frequent number of occurances of indicated substring
    * 
    * @param subS delimiter substring
    */
   private int mostFrequent(String subS) {
    int maxcnt = 500; // arbitrary limit of 500 occurances
    int[] freq = new int[maxcnt];  
      for (int i=0;i<nlines;i++) {
        int cnt = charCount(lines[i],subS);
        if (cnt>maxcnt-1) cnt = maxcnt-1;
        freq[cnt]++;
      }
      int mostfreq = 0;
      int mostfreqindex = 0;
      int tot = 0;
      for (int j=0;j<maxcnt;j++) {
        tot = tot + freq[j];
        if (freq[j]>mostfreq) {
          mostfreq = freq[j];
          mostfreqindex = j;
        }
      }
      // establish a threshold; if less than, then return 0
      if ( (100*mostfreq/tot)<80) mostfreq = 0;
      return mostfreqindex;
   }

  /**
   * guesses a delimiter based on frequency of appearance of common delimites
   */
  private String guessDelimiter() {
    if (mostFrequent("\t")>0) {
      parseOn = false;
      TabCheckBox.setSelected(true);
      CommaCheckBox.setSelected(false);
      SpaceCheckBox.setSelected(false);
      SemicolonCheckBox.setSelected(false);
      OtherCheckBox.setSelected(false);
      parseOn = true;
      return "tab";
    }
    else if (mostFrequent(",")>0) {
      parseOn = false;
      TabCheckBox.setSelected(false);
      CommaCheckBox.setSelected(true);
      SpaceCheckBox.setSelected(false);
      SemicolonCheckBox.setSelected(false);
      OtherCheckBox.setSelected(false);
      parseOn = true;
      return "comma";
    }
    else if (mostFrequent(" ")>0) {
      parseOn = false;
      TabCheckBox.setSelected(false);
      CommaCheckBox.setSelected(false);
      SpaceCheckBox.setSelected(true);
      SemicolonCheckBox.setSelected(false);
      OtherCheckBox.setSelected(false);
      parseOn = true;
      return "space";
    }
    else if (mostFrequent(";")>0) {
      parseOn = false;
      TabCheckBox.setSelected(false);
      CommaCheckBox.setSelected(false);
      SpaceCheckBox.setSelected(false);
      SemicolonCheckBox.setSelected(true);
      OtherCheckBox.setSelected(false);
      parseOn = true;
      return "semicolon";
    }
    else if (mostFrequent(":")>0) {
      parseOn = false;
      TabCheckBox.setSelected(false);
      CommaCheckBox.setSelected(false);
      SpaceCheckBox.setSelected(true);
      SemicolonCheckBox.setSelected(false);
      OtherCheckBox.setSelected(true);
      OtherTextField.setText(":");
      parseOn = true;
      return "colon";
    }
      parseOn = false;
      TabCheckBox.setSelected(false);
      CommaCheckBox.setSelected(false);
      SpaceCheckBox.setSelected(true);
      SemicolonCheckBox.setSelected(false);
      OtherCheckBox.setSelected(false);
      parseOn = true;
    return "unknown";
  }
  
  //000000000000000000000000000000000
  
  
  
  // ----------------------------------------------
  // routines for checking content of columns
  
  boolean isInteger(String s) {
    boolean res = true;
    try {
      int III = Integer.parseInt(s);
    }
    catch (Exception w) {
      res = false;
    }
    return res;
  }

  
  boolean isDouble(String s) {
    boolean res = true;
    try {
      Double III = Double.valueOf(s);
    }
    catch (Exception w) {
      res = false;
    }
    return res;
  }
  
  boolean isDate(String s) {
    boolean res = true;
    try {
      long III = Date.parse(s);
    }
    catch (Exception w) {
      res = false;
    }
    return res;
  }

  
  /**
   * guesses column type based on frequency of content
   * types include text, integer, floating point number, and date.
   * Guess is based on frequency of occurance
   * 
   * @param colNum column number
   */
  String guessColFormat(int colNum) {
    int minInt = 0;
    int maxInt = 0;
    int intSum = 0;
    double intAverage = 0.0;
    double doubleAverage = 0.0;
    double minDouble = 0;
    double maxDouble = 0;
    double doubleSum = 0.0;
    int integerCount = 0;
    int doubleCount = 0;
    int dateCount = 0;
    int emptyCount = 0;
    boolean firsttime = true;
    for (int i=0;i<vec.size();i++) {
      Vector v = (Vector)vec.elementAt(i);
      String str = (String)v.elementAt(colNum);
      if (str.trim().length()<1) {
        emptyCount++;
      }
      else {
        if (isInteger(str)) {
          integerCount++;
          int val = Integer.parseInt(str);
          if (firsttime) {
            maxInt = val;
            minInt = val;
            firsttime = false;
          }
          if (val>maxInt) maxInt = val;
          if (val<minInt) minInt = val;
          intSum = intSum+val;
          intAverage = ((double)(intSum))/integerCount;
//	      ColumnData cd = (ColumnData)colDataInfo.elementAt(colNum);
//          cd.colAverage = intAverage;
//          cd.colMin = minInt;
//          cd.colMax = maxInt;
        }
        else if (isDouble(str)) {
          doubleCount++;
          Double dval = new Double(str);
          double val = dval.doubleValue();
          if (firsttime) {
            maxDouble = val;
            minDouble = val;
            firsttime = false;
          }
          if (val>maxDouble) maxDouble = val;
          if (val<minDouble) minDouble = val;
          doubleSum = doubleSum+val;
          doubleAverage = ((doubleSum))/doubleCount;
//	      ColumnData cd = (ColumnData)colDataInfo.elementAt(colNum);
//          cd.colAverage = doubleAverage;
//          cd.colMin = minDouble;
//          cd.colMax = maxDouble;
        }
        if (isDate(str)) {
          dateCount++;
        }
      }
    }
    if (integerCount>doubleCount) {
      if ((integerCount>0)&&((100*(integerCount+emptyCount)/vec.size()))>90) {
	      ColumnData cd = (ColumnData)colDataInfo.elementAt(colNum);
          cd.colAverage = intAverage;
          cd.colMin = minInt;
          cd.colMax = maxInt;
        return "Integers";  
      }
    }
    if (doubleCount>integerCount) {
      if ((doubleCount>0)&&((100*(doubleCount+emptyCount)/vec.size()))>90) {
	      ColumnData cd = (ColumnData)colDataInfo.elementAt(colNum);
          cd.colAverage = doubleAverage;
          cd.colMin = minDouble;
          cd.colMax = maxDouble;
        return "Floating Point";  
      }
    }
    if ((dateCount>0)&&((100*(dateCount+emptyCount)/vec.size()))>90) {
      return "Date";  
    }
    return "Text";
  }
 
 /**
  *  creates a Vector containing all the unique items (Strings) in the
  *  column
  */
  Vector getUniqueColValues(int colNum) {
    Vector res = new Vector();
    for (int i=0;i<vec.size();i++) {
      Vector v = (Vector)vec.elementAt(i);
      String str = (String)v.elementAt(colNum);
      if (!str.equals("")) {  // ignore empty strings
        if (!res.contains(str)) {
            res.addElement(str);  
        }
      }
    }
    ColumnData cd = (ColumnData)colDataInfo.elementAt(colNum);
    cd.colUniqueItemsList = res;
    return res;
  }
  
 /**
  * Uses the assumed column type to check all values in a column.
  * If data is not the correct type, a message is added to the Results
  * StringBuffer.
  * 
  * @param colNum column number
  */
 void checkColumnInfo(int colNum) {
  ColumnData cd = (ColumnData)colDataInfo.elementAt(colNum);   
  if ((cd.colType.length())>0) {
      String type = cd.colType;
      if (type.equals("text")) {
      }
      else if (type.equals("integer")) {
        for (int j=0;j<vec.size();j++) {
          Vector v = (Vector)vec.elementAt(j);
          String str = (String)v.elementAt(colNum);
          if ((blankCheckFlag)||(str.length()>0)) {
            if (!isInteger(str)) {
                resultsBuffer.append("Item in col "+(colNum+1)+" and row "+(j+1)+" is NOT an integer!\n");
            }
          }
        }
      }
      else if (type.equals("double")) {
        for (int j=0;j<vec.size();j++) {
          Vector v = (Vector)vec.elementAt(j);
          String str = (String)v.elementAt(colNum);
          if ((blankCheckFlag)||(str.length()>0)) {
            if (!isDouble(str)) {
                resultsBuffer.append("Item in col "+(colNum+1)+" and row "+(j+1)+" is NOT a Floating Point number!\n");
            }
          }
        }
      }
      else if (type.equals("date")) {
        for (int j=0;j<vec.size();j++) {
          Vector v = (Vector)vec.elementAt(j);
          String str = (String)v.elementAt(colNum);
          if ((blankCheckFlag)||(str.length()>0)) {
            if (!isDate(str)) {
                resultsBuffer.append("Item in col "+(colNum+1)+" and row "+(j+1)+" is NOT a Date!\n");
            }
          }
        }
      }
  }
 }

  
  /**
   * attempts to check to see if a file is just text or is binary. Reads bytes in 
   * file and looks for '0'. If any '0's are found, assumed that the file is NOT a
   * text file.
   * 
   * @param filename
   */
  //000000000000000000000000000000000
  
 
 /* Checks a file to see if it is a text file by looking for bytes containing '0'
 */
   private boolean isTextFile(String filename) { 
     boolean text = true; 
     int res; 
     try { 
         FileInputStream in = new FileInputStream(filename); 
         while ((res = in.read())>-1) { 
             if (res==0) text = false; 
         } 
     } 
     catch (Exception e) {} 
     return text; 
 } 
  

	void ShowResultsButton_actionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.
			 
		ShowResultsButton_actionPerformed_Interaction1(event);
	}

	void ShowResultsButton_actionPerformed_Interaction1(java.awt.event.ActionEvent event)
	{
	  for (int i=0;i<colTitles.size();i++) {
	    checkColumnInfo(i);
	  }
	    
	  try {
			// ResultsFrame Create and show the ResultsFrame
			TextImportResultsFrame rf = new TextImportResultsFrame();
			rf.ResultsTextArea.setText(resultsBuffer.toString());
			rf.setVisible(true);
		} catch (java.lang.Exception e) {
		}
	}

	void ColumnNameTextField_actionPerformed(java.awt.event.ActionEvent event)
	{
    if (selectedCol>-1) {
        ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);
        cd.colName = ColumnNameTextField.getText();
      }

	}

	void ColumnLabelTextField_actionPerformed(java.awt.event.ActionEvent event)
	{
    if (selectedCol>-1) {
      if (colTitles.size()>0) {
        colTitles.removeElementAt(selectedCol);
        colTitles.insertElementAt(ColumnLabelTextField.getText(), selectedCol);
        buildTable(colTitles, vec);
        ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);
        cd.colTitle = ColumnLabelTextField.getText();
      }
    }
	}

	void ColumnUnitTextField_actionPerformed(java.awt.event.ActionEvent event)
	{
        if (selectedCol>-1) {
            ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);  
            cd.colUnits = ColumnUnitTextField.getText();
        }
	}


	void ColumnDefTextArea_focusLost(java.awt.event.FocusEvent event)
	{
    if (selectedCol>-1) {
        ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);
        cd.colDefinition = ColumnDefTextArea.getText();
      }
	}


	void ColumnNameTextField_focusLost(java.awt.event.FocusEvent event)
	{
    if (selectedCol>-1) {
        ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);
        cd.colName = ColumnNameTextField.getText();
      }
	}

	void ColumnLabelTextField_focusLost(java.awt.event.FocusEvent event)
	{
    if (selectedCol>-1) {
      if (colTitles.size()>0) {
        colTitles.removeElementAt(selectedCol);
        colTitles.insertElementAt(ColumnLabelTextField.getText(), selectedCol);
        buildTable(colTitles, vec);
        ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);
        cd.colTitle = ColumnLabelTextField.getText();
      }
    }
	}

	void ColumnUnitTextField_focusLost(java.awt.event.FocusEvent event)
	{
        if (selectedCol>-1) {
            ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);  
            cd.colUnits = ColumnUnitTextField.getText();
        }
	}

	void EnumCheckBox_itemStateChanged(java.awt.event.ItemEvent event)
	{
		if (selectedCol>-1) {
            ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);  
		    cd.useEnumerationList = EnumCheckBox.isSelected();    
		}
	}


	class SymListSelection implements javax.swing.event.ListSelectionListener
	{
		public void valueChanged(javax.swing.event.ListSelectionEvent event)
		{
			Object object = event.getSource();
			if (object == DataTypeList)
				DataTypeList_valueChanged(event);
		}
	}

	void DataTypeList_valueChanged(javax.swing.event.ListSelectionEvent event)
	{
    if (selectedCol>-1) {
      ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);  
      int indx = DataTypeList.getSelectedIndex();
      if (indx>-1) {
        cd.colType = (String)DataTypeList.getSelectedValue();
      }
    }
	}

	void StartingLineTextField_actionPerformed(java.awt.event.ActionEvent event)
	{
		String str = StartingLineTextField.getText();
		if (isInteger(str)) {
		  startingLine = (Integer.valueOf(str)).intValue();  
		}
		else {
		  startingLine = 1;
		  StartingLineTextField.setText("1");
		}
			 
	}

	class SymFocus extends java.awt.event.FocusAdapter
	{
		public void focusLost(java.awt.event.FocusEvent event)
		{
			Object object = event.getSource();
			if (object == StartingLineTextField)
				StartingLineTextField_focusLost(event);
			else if (object == ColumnDefTextArea)
				ColumnDefTextArea_focusLost(event);
			else if (object == ColumnNameTextField)
				ColumnNameTextField_focusLost(event);
			else if (object == ColumnLabelTextField)
				ColumnLabelTextField_focusLost(event);
			else if (object == ColumnUnitTextField)
				ColumnUnitTextField_focusLost(event);
			else if (object == MinTextField)
				MinTextField_focusLost(event);
			else if (object == MaxTextField)
				MaxTextField_focusLost(event);
			else if (object == uniq)
				uniq_focusLost(event);
		}
	}

	void StartingLineTextField_focusLost(java.awt.event.FocusEvent event)
	{
		String str = StartingLineTextField.getText();
		if (isInteger(str)) {
		  startingLine = (Integer.valueOf(str)).intValue();  
		}
		else {
		  startingLine = 1;
		  StartingLineTextField.setText("1");
		}			 
	}
	
	

	class SymItem implements java.awt.event.ItemListener
	{
		public void itemStateChanged(java.awt.event.ItemEvent event)
		{
			Object object = event.getSource();
			if (object == ColumnLabelsCheckBox)
				ColumnLabelsCheckBox_itemStateChanged(event);
			else if (object == TabCheckBox)
				TabCheckBox_itemStateChanged(event);
			else if (object == CommaCheckBox)
				CommaCheckBox_itemStateChanged(event);
			else if (object == SpaceCheckBox)
				SpaceCheckBox_itemStateChanged(event);
			else if (object == SemicolonCheckBox)
				SemicolonCheckBox_itemStateChanged(event);
			else if (object == OtherCheckBox)
				OtherCheckBox_itemStateChanged(event);
			else if (object == EnumCheckBox)
				EnumCheckBox_itemStateChanged(event);
		}
	}

	void ColumnLabelsCheckBox_itemStateChanged(java.awt.event.ItemEvent event)
	{
    labelsInStartingLine = ColumnLabelsCheckBox.isSelected();
  }
  
  
  

	void TabCheckBox_itemStateChanged(java.awt.event.ItemEvent event)
	{
	  if (parseOn) {
		  parseDelimited();
		}
	}

	void CommaCheckBox_itemStateChanged(java.awt.event.ItemEvent event)
	{
	  if (parseOn) {
		  parseDelimited();
		}
	}

	void SpaceCheckBox_itemStateChanged(java.awt.event.ItemEvent event)
	{
	  if (parseOn) {
  		parseDelimited();
  	}
	}

	void SemicolonCheckBox_itemStateChanged(java.awt.event.ItemEvent event)
	{
	  if (parseOn) {
		  parseDelimited();
		}
	}

	void OtherCheckBox_itemStateChanged(java.awt.event.ItemEvent event)
	{
	  if (parseOn) {
		  parseDelimited();
		}
	}
	
	/**
	 * Hardcoded routine to create an XML Attribute metadata string based on
	 * data
	 * ---BAD PRACTICE--- should use config to get info
	 */
	public String createXMLAttributeString() {
	  StringBuffer XMLBuffer = new StringBuffer();
	  XMLBuffer.append("<?xml version=\"1.0\"?>\n");
	  XMLBuffer.append("<!DOCTYPE eml-attribute PUBLIC \"-//ecoinformatics.org//eml-attribute-2.0.0beta6//EN\" \"eml-attribute.dtd\">\n");
	  XMLBuffer.append("<eml-attribute>\n");
	  XMLBuffer.append("    <identifier> </identifier>\n");
	  for (int i=0;i<colTitles.size();i++) {
	    ColumnData cd = (ColumnData)colDataInfo.elementAt(i);
	    XMLBuffer.append("    <attribute>\n");
	    XMLBuffer.append("        <attributeName> "+normalize(cd.colName)+"</attributeName>\n");
	    XMLBuffer.append("        <attributeLabel> "+normalize(cd.colTitle)+"</attributeLabel>\n");
	    XMLBuffer.append("        <attributeDefinition>"+normalize(cd.colDefinition)+"</attributeDefinition>\n");
	    XMLBuffer.append("        <unit> "+normalize(cd.colUnits)+"</unit>\n");
	    XMLBuffer.append("        <dataType> "+normalize(cd.colType)+"</dataType>\n");
	    XMLBuffer.append("        <attributeDomain>\n");
	    if (cd.colType.equals("Integers")||(cd.colType.equals("Floating Point"))) {
	        XMLBuffer.append("             <numericDomain>\n");
	        XMLBuffer.append("                <minimum>"+cd.colMin +"</minimum>\n");
	        XMLBuffer.append("                <maximum>"+cd.colMax +"</maximum>\n");
	        XMLBuffer.append("             </numericDomain>\n");
	    }
	    else if(cd.useEnumerationList) {
	        for (int k=0;k<cd.colUniqueItemsList.size();k++) {
	            XMLBuffer.append("             <enumeratedDomain>\n");
	            XMLBuffer.append("                <code>"+(String)cd.colUniqueItemsList.elementAt(k)+"</code>\n");
	            XMLBuffer.append("                <definition>"+(String)cd.colUniqueItemsDefs.elementAt(k)+"</definition>\n");
	            XMLBuffer.append("             </enumeratedDomain>\n");
	        }
	    }
	    else {
	        XMLBuffer.append("             <textDomain>\n");
	        XMLBuffer.append("                <definition>*</definition>\n");
	        XMLBuffer.append("             </textDomain>\n");
	    }
	    XMLBuffer.append("        </attributeDomain>\n");
	    XMLBuffer.append("        <missingValueCode> </missingValueCode>\n");
	    XMLBuffer.append("        <precision> </precision>\n");
	    XMLBuffer.append("    </attribute>\n");
    }	  
	  XMLBuffer.append("</eml-attribute>\n");
	  return XMLBuffer.toString();
	}

	/**
	 * Hardcoded routine to create an XML Table Entity metadata string based on
	 * data
	 * ---BAD PRACTICE--- should use config to get info
	 */
	public String createXMLEntityString() {
	  StringBuffer XMLBuffer = new StringBuffer();
	  XMLBuffer.append("<?xml version=\"1.0\"?>\n");
	  XMLBuffer.append("<!DOCTYPE table-entity PUBLIC \"-//ecoinformatics.org//eml-entity-2.0.0beta6//EN\" \"eml-entity.dtd\">\n");
	  XMLBuffer.append("<table-entity>\n");
	  XMLBuffer.append("    <identifier> </identifier>\n");
	  XMLBuffer.append("    <entityName> "+normalize(TableNameTextField.getText())+"</entityName>\n");
	  XMLBuffer.append("    <entityDescription> "+normalize(TableDescriptionTextField.getText())+"</entityDescription>\n");
	  XMLBuffer.append("    <orientation columnorrow=\"columnmajor\"></orientation>\n");
	  XMLBuffer.append("    <caseSensitive yesorno=\"no\"></caseSensitive>\n");
	  String numRecords = (new Integer(nlines - startingLine + 1)).toString();
	  XMLBuffer.append("    <numberOfRecords> "+normalize(numRecords)+"</numberOfRecords>\n");
	  XMLBuffer.append("</table-entity>\n");
	  return XMLBuffer.toString();
	}

	/**
	 * Hardcoded routine to create an XML eml-physical metadata string based on
	 * data
	 * ---BAD PRACTICE--- should use config to get info
	 */
	public String createXMLPhysicalString() {
	  long filesize = (new File(filename)).length();
	  String filesizeString = (new Long(filesize)).toString();
	  String delimit = getDelimiterStringAsText();
	  StringBuffer XMLBuffer = new StringBuffer();
	  int numHeaderLines = startingLine;
	  if (!labelsInStartingLine) numHeaderLines = numHeaderLines-1;
	  
	  XMLBuffer.append("<?xml version=\"1.0\"?>\n");
	  XMLBuffer.append("<!DOCTYPE eml-physical PUBLIC \"-//ecoinformatics.org//eml-physical-2.0.0beta6//EN\" \"eml-physical.dtd\">\n");
	  XMLBuffer.append("<eml-physical>\n");
	  XMLBuffer.append("    <identifier> </identifier>\n");
      XMLBuffer.append("    <format> Text</format>\n");  // text import wizard only handles text 
      XMLBuffer.append("    <size unit=\"bytes\">"+filesizeString+"</size>\n");  
      XMLBuffer.append("    <numHeaderLines>"+numHeaderLines+"</numHeaderLines>\n");  
      XMLBuffer.append("    <recordDelimiter>"+"#x0A"+"</recordDelimiter>\n"); 
      XMLBuffer.append("    <fieldDelimiter>"+delimit+"</fieldDelimiter>\n"); 
      XMLBuffer.append("</eml-physical>\n");
	  return XMLBuffer.toString();
    }


	void saveEmlAttribute_actionPerformed(java.awt.event.ActionEvent event)
	{
		try {
			// saveFileDialog Show the FileDialog
			saveFileDialog.setFile("table_attributes.xml");
			saveFileDialog.setVisible(true);
		String filepath = saveFileDialog.getDirectory()+saveFileDialog.getFile();
		System.out.println(filepath);
		String table_entityString = createXMLAttributeString();
		StringReader in = new StringReader(table_entityString);
		FileWriter out = new FileWriter(filepath);
        int c;

        while ((c = in.read()) != -1)
           out.write(c);

        in.close();
        out.close();
		} catch (Exception e) {}
	}

	void CancelButton_actionPerformed(java.awt.event.ActionEvent event)
	{
		this.setVisible(false);
		this.dispose();
    if(listener != null)
    {
      listener.importCanceled();
    }
	}
	
	
    /** Normalizes the given string. */
    private String normalize(Object ss) {
        String s = "";
        s = (String)ss;
        StringBuffer str = new StringBuffer();

        int len = (s != null) ? s.length() : 0;
        for (int i = 0; i < len; i++) {
            char ch = s.charAt(i);
            switch (ch) {
                case '<': {
                    str.append("&lt;");
                    break;
                }
                case '>': {
                    str.append("&gt;");
                    break;
                }
                case '&': {
                    str.append("&amp;");
                    break;
                }
                case '"': {
                    str.append("&quot;");
                    break;
                }
                case '\r':
		case '\t':
                case '\n': {
                    if (false) {
                        str.append("&#");
                        str.append(Integer.toString(ch));
                        str.append(';');
                        break;
                    }
                    // else, default append char
			break;
                }
                default: {
                    str.append(ch);
                }
            }
        }

        return str.toString();

    } // normalize(String):String

	private String checkForBlankInfo() {
	    String res = null;  // return null if all fields have data
	    String temp = "";
	    for (int i=0;i<colDataInfo.size();i++) {
	        ColumnData cd = (ColumnData)colDataInfo.elementAt(i);
	        if (!cd.hasInfo()) {
	            temp = temp + "#" + (i+1) +" ";
	        }
	    }
	    if (temp.length()>0) res = temp;
	    return res;
    }
    
/**
 *  class to store all the metadate about the data in a column of the table
 *
 */
	private class ColumnData
	{
	    int colNumber;
	    String colTitle = "";
	    String colName = "";
	    String colDefinition = "";
	    String colType = "";
	    String colUnits = "";
	    int colNumUniqueItems;
	    double colMin = 0.0;
	    double colMax = 0.0;
	    double colAverage = 0.0;
	    Vector colUniqueItemsList;
	    Vector colUniqueItemsDefs;
	    boolean useEnumerationList = false;
	    
	    ColumnData(int colnum) {
	        this.colNumber = colnum;    
	    }
	    
	    boolean hasInfo() {
	        boolean res = true;
	        if (colTitle.length()==0) res=false;
	        if (colName.length()==0) res=false;
	        if (colDefinition.length()==0) res=false;
	        if (colType.length()==0) res=false;
	   //     if (colUnits.length()==0) res=false;
	        return res;
	    }
	}
	



	void MinTextField_actionPerformed(java.awt.event.ActionEvent event)
	{
        if (selectedCol>-1) {
            ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);  
            cd.colMin = (new Double(MinTextField.getText())).doubleValue();
        }
	}

	void MinTextField_focusLost(java.awt.event.FocusEvent event)
	{
        if (selectedCol>-1) {
            ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);  
            cd.colMin = (new Double(MinTextField.getText())).doubleValue();
        }
	}

	void MaxTextField_actionPerformed(java.awt.event.ActionEvent event)
	{
        if (selectedCol>-1) {
            ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);  
            cd.colMax = (new Double(MaxTextField.getText())).doubleValue();
        }
	}

	void MaxTextField_focusLost(java.awt.event.FocusEvent event)
	{
        if (selectedCol>-1) {
            ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);  
            cd.colMax = (new Double(MaxTextField.getText())).doubleValue();
        }
	}

	void uniq_focusLost(java.awt.event.FocusEvent event)
	{
	  if (selectedCol>-1) {
        ColumnData cd = (ColumnData)colDataInfo.elementAt(selectedCol);  
		DefaultTableModel dtm = (DefaultTableModel)uniq.getModel();
        int cnt = dtm.getRowCount();
        Vector codes = new Vector();
        Vector defs = new Vector();
        for (int i=0;i<cnt;i++) {
          String code = (String)dtm.getValueAt(i, 0);
          String definition = (String)dtm.getValueAt(i, 1);
          if ((code.length()>0)) {
            codes.addElement(code);
            defs.addElement(definition);
          }
        }
        cd.colUniqueItemsList = codes;
        cd.colUniqueItemsDefs = defs;
      }
	}
}
