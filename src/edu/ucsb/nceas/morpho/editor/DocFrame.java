/**
 *        Name: DocFrame.java
 *  Copyright: 2000 Regents of the University of California and the
 *              National Center for Ecological Analysis and Synthesis
 *    Authors: @higgins@
 *    Release: @release@
 *
 *   '$Author: higgins $'
 *     '$Date: 2001-05-07 16:19:37 $'
 * '$Revision: 1.2 $'
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */



import java.awt.*;
import javax.swing.*;
import java.awt.event.*;
import java.net.URL;
import java.io.*;
import javax.swing.event.*;
import com.arbortext.catalog.*;
import org.xml.sax.SAXException;
import org.apache.xalan.xslt.XSLTProcessorFactory;
import org.apache.xalan.xslt.XSLTInputSource;
import org.apache.xalan.xslt.XSLTResultTarget;
import org.apache.xalan.xslt.XSLTProcessor;
import org.apache.xalan.xpath.xml.*;
import java.util.PropertyResourceBundle;
import javax.swing.*;
import javax.swing.tree.*;

import org.xml.sax.*;
import org.xml.sax.helpers.*;
import java.util.*;
import edu.ucsb.nceas.morpho.framework.*;


public class DocFrame extends javax.swing.JFrame
{
    ConfigXML config;
    File file;
    String XMLTextString;
    String doctype = null;
    public DefaultTreeModel treeModel;
//    public MyDefaultTreeModel treeModel;
    public DefaultMutableTreeNode rootNode;
    DefaultMutableTreeNode selectedNode;
    public JTree tree;
    private boolean transform_flag = true;
    static public Hashtable ht;
    StringBuffer sb; 
    
    javax.swing.JMenuItem CMmenuItem;
    javax.swing.JMenuItem menuItem;
    javax.swing.JMenuItem CardmenuItem;
    javax.swing.JMenuItem DeletemenuItem;
    javax.swing.JMenuItem DupmenuItem;
    
    
    static {
        ht = new Hashtable();
        ht.put("eml-dataset" , "eml-dataset-display.xsl");
        ht.put("eml-file" , "eml-file-display.xsl");
        ht.put("eml-variable" , "eml-variable-display.xsl");
        ht.put("resource", "resource.xsl");
//        ht.put("eml-access" , "eml-dataset-display.xsl");
        
    }
    
	public DocFrame()
	{
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		setDefaultCloseOperation(javax.swing.JFrame.DISPOSE_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout(0,0));
		setSize(405,305);
		setVisible(false);
		DocControlPanel.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
		getContentPane().add(BorderLayout.NORTH, DocControlPanel);
		JTabbedPane1.setTabPlacement(javax.swing.JTabbedPane.BOTTOM);
		getContentPane().add(BorderLayout.CENTER, JTabbedPane1);
		JScrollPane1.setOpaque(true);
		JTabbedPane1.add(JScrollPane1);
		JScrollPane1.setBounds(2,2,400,265);
		JScrollPane1.setVisible(false);
		XMLText.setLineWrap(true);
		XMLText.setWrapStyleWord(true);
		JScrollPane1.getViewport().add(XMLText);
		XMLText.setBounds(0,0,397,262);
		JScrollPane2.setOpaque(true);
		JTabbedPane1.add(JScrollPane2);
		JScrollPane2.setBounds(2,2,400,265);
		JScrollPane2.setVisible(false);
		HTMLPane.setEditable(false);
		JScrollPane2.getViewport().add(HTMLPane);
		HTMLPane.setBounds(0,0,397,262);
		JPanel1.setLayout(new BorderLayout(0,0));
		JTabbedPane1.add(JPanel1);
		JPanel1.setBounds(2,2,400,265);
		JPanel1.setVisible(false);
		JPanel1.add(BorderLayout.WEST, OutputScrollPanel);
		JPanel1.add(BorderLayout.CENTER, NestedPanelScrollPanel);
		JPanel2.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
		JPanel1.add(BorderLayout.NORTH, JPanel2);
		reload.setText("Reload Tree");
		reload.setActionCommand("Reload Tree");
		JPanel2.add(reload);
		JTabbedPane1.setSelectedIndex(0);
		JTabbedPane1.setSelectedComponent(JScrollPane1);
		JTabbedPane1.setTitleAt(0,"Text");
		JTabbedPane1.setTitleAt(1,"HTML");
		JTabbedPane1.setTitleAt(2,"Tree");
		//}}

		//{{INIT_MENUS
		//}}
          //    CMmenuItem = new JMenuItem("Content Model = ");
             // menuItem.addActionListener(this);
         //     popup.add(CMmenuItem);
         //     CardmenuItem = new JMenuItem("One Element Allowed");
            //  menuItem.addActionListener(this);
         //     popup.add(CardmenuItem);
         //     popup.add(new JSeparator());
              DupmenuItem = new JMenuItem("Duplicate");
              popup.add(DupmenuItem);
              DeletemenuItem = new JMenuItem("Delete");
              popup.add(DeletemenuItem);
	
		//{{REGISTER_LISTENERS
		SymAction lSymAction = new SymAction();
		SymChange lSymChange = new SymChange();
		JTabbedPane1.addChangeListener(lSymChange);
		reload.addActionListener(lSymAction);
		//}}
		DeletemenuItem.addActionListener(lSymAction);
		DupmenuItem.addActionListener(lSymAction);
		
        //Create the popup menu.
        javax.swing.JPopupMenu popup = new JPopupMenu();
		
		rootNode = newNode("Configuration");
//		treeModel = new MyDefaultTreeModel(rootNode);
		treeModel = new DefaultTreeModel(rootNode);

        tree = new JTree(treeModel);
		OutputScrollPanel.getViewport().add(tree);
    	tree.setCellRenderer(new XMLTreeCellRenderer());
		
		tree.setShowsRootHandles(true);
        tree.setEditable(false);
        tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        tree.setShowsRootHandles(true);
        tree.putClientProperty("JTree.lineStyle", "Angled");
		
		SymTreeSelection lSymTreeSelection = new SymTreeSelection();
		tree.addTreeSelectionListener(lSymTreeSelection);
	
		MouseListener popupListener = new PopupListener();
        tree.addMouseListener(popupListener);
		
		
	}

	public DocFrame(String sTitle)
	{
		this();
		setTitle(sTitle);
	}

	public DocFrame(String sTitle, String doctext)
	{
		this();
		setTitle(sTitle);
		XMLTextString = doctext;
		XMLText.setText(doctext);
		putXMLintoTree();
        JTabbedPane1.setSelectedIndex(1);
        tree.setSelectionRow(0);
	}
	
	public DocFrame(File file)
	{
	    this();
	    this.file = file;
	}
	
	public void setFile(File f) {
	    file = f;
	}
	
	public void setDoctype(String doctype) {
	    this.doctype = doctype;
	}   

	public void setVisible(boolean b)
	{
		if (b)
			setLocation(50, 50);
		super.setVisible(b);
	}

	static public void main(String args[])
	{
		(new DocFrame()).setVisible(true);
	}

	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension size = getSize();

		super.addNotify();

		if (frameSizeAdjusted)
			return;
		frameSizeAdjusted = true;

		// Adjust size of frame according to the insets and menu bar
		Insets insets = getInsets();
		javax.swing.JMenuBar menuBar = getRootPane().getJMenuBar();
		int menuBarHeight = 0;
		if (menuBar != null)
			menuBarHeight = menuBar.getPreferredSize().height;
		setSize(insets.left + insets.right + size.width, insets.top + insets.bottom + size.height + menuBarHeight);
	}

	// Used by addNotify
	boolean frameSizeAdjusted = false;

	//{{DECLARE_CONTROLS
	javax.swing.JPanel DocControlPanel = new javax.swing.JPanel();
	javax.swing.JTabbedPane JTabbedPane1 = new javax.swing.JTabbedPane();
	javax.swing.JScrollPane JScrollPane1 = new javax.swing.JScrollPane();
	javax.swing.JTextArea XMLText = new javax.swing.JTextArea();
	javax.swing.JScrollPane JScrollPane2 = new javax.swing.JScrollPane();
	javax.swing.JEditorPane HTMLPane = new javax.swing.JEditorPane();
	javax.swing.JPanel JPanel1 = new javax.swing.JPanel();
	javax.swing.JScrollPane OutputScrollPanel = new javax.swing.JScrollPane();
	javax.swing.JScrollPane NestedPanelScrollPanel = new javax.swing.JScrollPane();
	javax.swing.JPanel JPanel2 = new javax.swing.JPanel();
	javax.swing.JButton reload = new javax.swing.JButton();
	//}}

	//{{DECLARE_MENUS
	//}}
	            //Create the popup menu.
              javax.swing.JPopupMenu popup = new JPopupMenu();

	
public void writeInfo() {
    try{
    FileReader in = new FileReader(file);
    StringWriter out = new StringWriter();
    int c;
    while ((c = in.read()) != -1) {
        out.write(c);
        }
        in.close();
        out.close();
        XMLTextString = out.toString();
    XMLText.setText(out.toString());
		putXMLintoTree();
        JTabbedPane1.setSelectedIndex(1);
        tree.setSelectionRow(0);
        
    }
	catch (Exception e) {;}
    
    }

	class SymAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			if (object == DeletemenuItem)
				Del_actionPerformed(event);
			else if (object == DupmenuItem)
				Dup_actionPerformed(event);
			else if (object == reload)
				reload_actionPerformed(event);
			
		}
	}

	void TransformToHTML()
	{
                CatalogEntityResolver cer = new CatalogEntityResolver();
		        config = new ConfigXML("config.xml");
		        String local_dtd_directory = config.get("local_dtd_directory",0);
		        String local_xml_directory = config.get("local_xml_directory",0);
//            	PropertyResourceBundle options = (PropertyResourceBundle)PropertyResourceBundle.getBundle("client");  // DFH
//            	String local_dtd_directory =(String)options.handleGetObject("local_dtd_directory");     // DFH
//            	String local_xml_directory =(String)options.handleGetObject("local_xml_directory");     // DFH
            
            	String xmlcatalogfile = local_dtd_directory+"/catalog"; 
               // String xmlcatalogfile = "./catalog/catalog"; 
                
                try {
                    Catalog myCatalog = new Catalog();
                    myCatalog.loadSystemCatalogs();
                    myCatalog.parseCatalog(xmlcatalogfile);
                    cer.setCatalog(myCatalog);
                }
        catch (Exception e) {System.out.println("Problem creating Catalog!");}
	    
	try{
    // Have the XSLTProcessorFactory obtain a interface to a
    // new XSLTProcessor object.
    StringReader sr = null;
    if (XMLTextString!=null) {
        sr = new StringReader(XMLTextString);
    }
    XSLTProcessor processor = XSLTProcessorFactory.getProcessor();
    XMLParserLiaison pl = processor.getXMLProcessorLiaison();
    pl.setEntityResolver(cer);

    // Have the XSLTProcessor processor object transform "foo.xml" to
    // System.out, using the XSLT instructions found in "foo.xsl".
//    processor.process(new XSLTInputSource("file:///"+file.getCanonicalPath()),
    XSLTInputSource trans = null;
    
    String fileString = "xml2html.xsl";
    if (doctype!=null) {
        if (ht.get(doctype)!=null) {
            fileString = (String)ht.get(doctype);
        }
    }
    FileReader fr = new FileReader(fileString);
    trans = new XSLTInputSource(fr);    
        
    processor.process(new XSLTInputSource(sr),
                      trans,
                      new XSLTResultTarget("html.out"));
    File html = new File("html.out");
    HTMLPane.setPage("file:///"+html.getAbsolutePath());
    JTabbedPane1.setSelectedIndex(1);
    }
    catch (Exception w) {}
	}
		
void putXMLintoTree() {
    if (XMLTextString!=null) {
          CatalogEntityResolver cer = new CatalogEntityResolver();
		ConfigXML config = new ConfigXML("config.xml");
          String local_dtd_directory =config.get("local_dtd_directory",0);     // DFH
          String local_xml_directory =config.get("local_xml_directory",0);     // DFH
            
          String xmlcatalogfile = local_dtd_directory+"/catalog"; 
          try {
               Catalog myCatalog = new Catalog();
               myCatalog.loadSystemCatalogs();
               myCatalog.parseCatalog(xmlcatalogfile);
               cer.setCatalog(myCatalog);
                }
        catch (Exception e) {System.out.println("Problem creating Catalog!");}
        try {
            StringReader sr = new StringReader(XMLTextString);
            String parserName = "org.apache.xerces.parsers.SAXParser";
            XMLReader parser = null;
          // Get an instance of the parser
            parser = XMLReaderFactory.createXMLReader(parserName);
            XMLDisplayHandler mh = new XMLDisplayHandler(treeModel);
            parser.setContentHandler(mh);
	    parser.setEntityResolver(cer);
            parser.parse(new InputSource(sr));
            DefaultMutableTreeNode rt = (DefaultMutableTreeNode)treeModel.getRoot();
            doctype = ((NodeInfo)rt.getUserObject()).toString();
            } catch (Exception e) { 
           System.err.println(e.toString());
        }
    }
}

	public DefaultMutableTreeNode newNode (Object name) {
	    NodeInfo ni = new NodeInfo(name.toString());
	    DefaultMutableTreeNode node = new DefaultMutableTreeNode(ni);
	    return node;
	}
	
	class SymTreeSelection implements javax.swing.event.TreeSelectionListener
	{
		public  void valueChanged(javax.swing.event.TreeSelectionEvent event)
		{
			Object object = event.getSource();
			if (object == tree)
				tree_valueChanged(event);
		}
	}

	 void tree_valueChanged(javax.swing.event.TreeSelectionEvent event)
	{
	    TreePath tp = event.getNewLeadSelectionPath();
	    if (tp!=null) {
	    Object ob = tp.getLastPathComponent();
	    DefaultMutableTreeNode node = null;
	    if (ob!=null) {node =(DefaultMutableTreeNode)ob;}
         selectedNode = node;
         XMLPanels xp = new XMLPanels(node);
         xp.setTreeModel(treeModel);
         NestedPanelScrollPanel.getViewport().add(xp.topPanel);
         xp.invalidate();
         NestedPanelScrollPanel.repaint();
		}
		
		
	}  

	class SymChange implements javax.swing.event.ChangeListener
	{
		public void stateChanged(javax.swing.event.ChangeEvent event)
		{
			Object object = event.getSource();
			if (object == JTabbedPane1)
				JTabbedPane1_stateChanged(event);
		}
	}

	void JTabbedPane1_stateChanged(javax.swing.event.ChangeEvent event)
	{
		if((JTabbedPane1.getSelectedIndex()==1)&&(transform_flag)) {
		    TransformToHTML();
		    transform_flag=false;
		}
			 
	}
	
    class PopupListener extends MouseAdapter {
        // on the Mac, popups are triggered on mouse pressed, while mouseReleased triggers them
        // on the PC; use the trigger flag to record a trigger, but do not show popup until the
        // mouse released event
        boolean trigger = false;
              public void mousePressed(MouseEvent e) {
                 // maybeShowPopup(e);
                 if (e.isPopupTrigger()) {
                    trigger = true;
                 }  
              }

              public void mouseReleased(MouseEvent e) {
                  maybeShowPopup(e);
              }

              private void maybeShowPopup(MouseEvent e) {
                  if ((e.isPopupTrigger())||(trigger)) {
                       trigger = false;
                       TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());
                       tree.setSelectionPath(selPath);
                       if (selectedNode!=null) {
                        
                        NodeInfo ni = (NodeInfo)selectedNode.getUserObject();
//                        if (getCM(ni.getName())!=null) {
//                            CMmenuItem.setText("Content: "+getCM(ni.getName()));
//                        }
//                        if (ni.getCardinality()!=null) {
//                            CardmenuItem.setText("Number: "+ni.getCardinality());
//                        }
                        String temp = (String)ni.attr.get("copyNode");
                        if ((temp!=null)&&(temp.equalsIgnoreCase("false"))){
                            DupmenuItem.setEnabled(false);   
                        }
                        else {
                           DupmenuItem.setEnabled(true); 
                        }
                        temp = (String)ni.attr.get("deleteNode");
                        if ((temp!=null)&&(temp.equalsIgnoreCase("false"))){
                            DeletemenuItem.setEnabled(false);   
                        }
                        else {
                           DeletemenuItem.setEnabled(true); 
                        }
                      }
                     popup.show(e.getComponent(), e.getX(), e.getY());
                      
                  }
              }
              
    public String getCM(String elemName) {
        String str = null;
//       if (dtd!=null) {
//		DTDElement elem = (DTDElement)dtd.elements.get(elemName);
//		if (elem!=null) {
//		    sb = new StringBuffer();
//		    str = dumpDTDItem(elem.content);
//		}
//		}
		return str;
    }
              
              
              
    }	
	
	
public DefaultMutableTreeNode deepNodeCopy(DefaultMutableTreeNode node) {
    DefaultMutableTreeNode newnode = null; 
    try{
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ObjectOutputStream s = new ObjectOutputStream(out);
        s.writeObject(node);
        s.flush();
        
       // now read it
       ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
        ObjectInputStream os = new ObjectInputStream(in);
        newnode = (DefaultMutableTreeNode)os.readObject();
    }
    catch (Exception e) {
        System.out.println("Exception in creating copy of node!");
    }
        return newnode;
       
}
	
	

	void Dup_actionPerformed(java.awt.event.ActionEvent event)
	{
	    TreePath tp = tree.getSelectionPath();
	    if (tp!=null) {
	    Object ob = tp.getLastPathComponent();
	    DefaultMutableTreeNode node = (DefaultMutableTreeNode)ob;
	    DefaultMutableTreeNode par = (DefaultMutableTreeNode)node.getParent();
	    int iii = par.getIndex(node);
	    DefaultMutableTreeNode newnode = deepNodeCopy(node);
	    tree.expandPath(tp);
	    par.insert(newnode,iii);
	    treeModel.reload(par);
	    }
			 
	}

	void Del_actionPerformed(java.awt.event.ActionEvent event)
	{
        TreePath currentSelection = tree.getSelectionPath();
        if (currentSelection != null) {
            DefaultMutableTreeNode currentNode = (DefaultMutableTreeNode)(currentSelection.getLastPathComponent());
            NodeInfo ni = (NodeInfo)currentNode.getUserObject();
            String curNodeName = ni.getName();
            int cnt = 0;
            MutableTreeNode parent = (MutableTreeNode)(currentNode.getParent());
            if (parent != null) {
                Enumeration eee = parent.children();
                while (eee.hasMoreElements()) {
                    DefaultMutableTreeNode cn = (DefaultMutableTreeNode)eee.nextElement();
                    NodeInfo ni1 = (NodeInfo)cn.getUserObject();
                    String name = ni1.getName();
                    if (name.equals(curNodeName)) {
                        cnt++;
                    }
                }
            }
            if ((parent != null)&&(cnt>1)) {
                treeModel.removeNodeFromParent(currentNode);
                return;
            }
        } 

        // Either there was no selection, or the root was selected.
        Toolkit.getDefaultToolkit().beep();
		
			 
	}
	
	

	void reload_actionPerformed(java.awt.event.ActionEvent event)
	{
		treeModel.reload();
			 
	}
}