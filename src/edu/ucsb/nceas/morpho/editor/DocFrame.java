/**
 *        Name: DocFrame.java
 *  Copyright: 2000 Regents of the University of California and the
 *              National Center for Ecological Analysis and Synthesis
 *    Authors: @higgins@
 *    Release: @release@
 *
 *   '$Author: higgins $'
 *     '$Date: 2001-05-24 23:39:18 $'
 * '$Revision: 1.6 $'
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package edu.ucsb.nceas.morpho.editor;


import java.awt.*;
import javax.swing.*;
import java.awt.event.*;
import java.net.URL;
import java.io.*;
import javax.swing.event.*;
import com.arbortext.catalog.*;
import org.xml.sax.SAXException;
import org.apache.xalan.xslt.XSLTProcessorFactory;
import org.apache.xalan.xslt.XSLTInputSource;
import org.apache.xalan.xslt.XSLTResultTarget;
import org.apache.xalan.xslt.XSLTProcessor;
import org.apache.xalan.xpath.xml.*;
import java.util.PropertyResourceBundle;
import javax.swing.*;
import javax.swing.tree.*;

import org.xml.sax.*;
import org.xml.sax.helpers.*;
import java.util.*;
import edu.ucsb.nceas.morpho.framework.*;


/**
 * DocFrame is an example container for an XML editor which
 * shows combined outline and nested panel views of an XML
 * document.
 * 
 * @author higgins
 */
public class DocFrame extends javax.swing.JFrame
{
    ConfigXML config;
    File file;
    
    /* the string representation of the XML being displayed */
    String XMLTextString;
    
    /* the publicID, if available, or the systemID, if available,
     * or the rootnode name
     */
    String doctype = null;
    
    // various global variables
    public DefaultTreeModel treeModel;
    public DefaultMutableTreeNode rootNode;
    DefaultMutableTreeNode selectedNode;
    public JTree tree;
    StringBuffer sb; 
    
    javax.swing.JMenuItem DeletemenuItem;
    javax.swing.JMenuItem DupmenuItem;
    
    
 /**
  * This constructor builds the contents of the DocFrame Display
  */
  
	public DocFrame()
	{
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		setDefaultCloseOperation(javax.swing.JFrame.DISPOSE_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout(0,0));
		setSize(600,305);
		setVisible(false);
		getContentPane().add(OutputScrollPanel);
		getContentPane().add(BorderLayout.CENTER,NestedPanelScrollPanel);
		
		getContentPane().add(BorderLayout.NORTH, ControlPanel);
		ControlPanel.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
		reload.setText("Reload Tree");
		reload.setActionCommand("Reload Tree");
		ControlPanel.add(reload);
		DTDParse.setText("Parse DTD");
		DTDParse.setActionCommand("Parse DTD");
		ControlPanel.add(DTDParse);
		//}}
		JSplitPane DocControlPanel = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT
		       , OutputScrollPanel, NestedPanelScrollPanel);
		     
		DocControlPanel.setOneTouchExpandable(true);
    DocControlPanel.setDividerLocation(250); 
    getContentPane().add(BorderLayout.CENTER, DocControlPanel);

		//{{INIT_MENUS
		//}}
    DupmenuItem = new JMenuItem("Duplicate");
    popup.add(DupmenuItem);
    DeletemenuItem = new JMenuItem("Delete");
    popup.add(DeletemenuItem);
	
		//{{REGISTER_LISTENERS
		SymAction lSymAction = new SymAction();
		SymChange lSymChange = new SymChange();
		reload.addActionListener(lSymAction);
		DTDParse.addActionListener(lSymAction);
		//}}
		DeletemenuItem.addActionListener(lSymAction);
		DupmenuItem.addActionListener(lSymAction);
		
    //Create the popup menu.
    javax.swing.JPopupMenu popup = new JPopupMenu();
		
		rootNode = newNode("Configuration");
		treeModel = new DefaultTreeModel(rootNode);

    tree = new JTree(treeModel);
		OutputScrollPanel.getViewport().add(tree);
    tree.setCellRenderer(new XMLTreeCellRenderer());
		
		tree.setShowsRootHandles(true);
    tree.setEditable(false);
    tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
    tree.setShowsRootHandles(true);
    tree.putClientProperty("JTree.lineStyle", "Angled");
		
		SymTreeSelection lSymTreeSelection = new SymTreeSelection();
		tree.addTreeSelectionListener(lSymTreeSelection);
	
		MouseListener popupListener = new PopupListener();
    tree.addMouseListener(popupListener);
	}

	/**
	 *  Constructor which adds a title string to the Frame
	 */
	 
	public DocFrame(String sTitle)
	{
		this();
		setTitle(sTitle);
	}

  /** 
   *  Constructor which adds a title and passes the xml to
   *  display as a string; puts XML into tree
   */
   
	public DocFrame(String sTitle, String doctext)
	{
		this();
		setTitle(sTitle);
		XMLTextString = doctext;
		putXMLintoTree();
    tree.setSelectionRow(0);
	}
	
	public DocFrame(File file)
	{
	    this();
	    this.file = file;
	}
	
	public void setFile(File f) {
	    file = f;
	}
	
	public void setDoctype(String doctype) {
	    this.doctype = doctype;
	}   

	public void setVisible(boolean b)
	{
		if (b)
			setLocation(50, 50);
		super.setVisible(b);
	}

	static public void main(String args[])
	{
		(new DocFrame()).setVisible(true);
	}

	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension size = getSize();

		super.addNotify();

		if (frameSizeAdjusted)
			return;
		frameSizeAdjusted = true;

		// Adjust size of frame according to the insets and menu bar
		Insets insets = getInsets();
		javax.swing.JMenuBar menuBar = getRootPane().getJMenuBar();
		int menuBarHeight = 0;
		if (menuBar != null)
			menuBarHeight = menuBar.getPreferredSize().height;
		setSize(insets.left + insets.right + size.width, insets.top + insets.bottom + size.height + menuBarHeight);
	}

	// Used by addNotify
	boolean frameSizeAdjusted = false;

	//{{DECLARE_CONTROLS
	javax.swing.JScrollPane OutputScrollPanel = new javax.swing.JScrollPane();
	javax.swing.JScrollPane NestedPanelScrollPanel = new javax.swing.JScrollPane();
	javax.swing.JPanel ControlPanel = new javax.swing.JPanel();
	javax.swing.JButton reload = new javax.swing.JButton();
	javax.swing.JButton DTDParse = new javax.swing.JButton();
	//}}

	//{{DECLARE_MENUS
	//}}
	//Create the popup menu.
  javax.swing.JPopupMenu popup = new JPopupMenu();

	
public void writeInfo() {
  try{
    FileReader in = new FileReader(file);
    StringWriter out = new StringWriter();
    int c;
    while ((c = in.read()) != -1) {
        out.write(c);
    }
    in.close();
    out.close();
    XMLTextString = out.toString();
		putXMLintoTree();
    tree.setSelectionRow(0);
    }
	catch (Exception e) {;}
    
}

class SymAction implements java.awt.event.ActionListener {
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			if (object == DeletemenuItem)
				Del_actionPerformed(event);
			else if (object == DupmenuItem)
				Dup_actionPerformed(event);
			else if (object == reload)
				reload_actionPerformed(event);
			else if (object == DTDParse)
				DTDParse_actionPerformed(event);
		}
}

		
void putXMLintoTree() {
  if (XMLTextString!=null) {
    CatalogEntityResolver cer = new CatalogEntityResolver();
    ConfigXML config = new ConfigXML("lib/config.xml");
    String local_dtd_directory =config.get("local_dtd_directory",0);     
    String local_xml_directory =config.get("local_xml_directory",0);     
            
    String xmlcatalogfile = local_dtd_directory+"/catalog"; 
    try {
      Catalog myCatalog = new Catalog();
      myCatalog.loadSystemCatalogs();
      myCatalog.parseCatalog(xmlcatalogfile);
      cer.setCatalog(myCatalog);
    }
    catch (Exception e) {System.out.println("Problem creating Catalog!");}
    try {
      StringReader sr = new StringReader(XMLTextString);
      String parserName = "org.apache.xerces.parsers.SAXParser";
      XMLReader parser = null;
      // Get an instance of the parser
      parser = XMLReaderFactory.createXMLReader(parserName);
      XMLDisplayHandler mh = new XMLDisplayHandler(treeModel);
      parser.setContentHandler(mh);
	    parser.setEntityResolver(cer);
	    InputSource is = new InputSource(sr);
      if (is.getPublicId()!=null) {
        doctype = is.getPublicId();
      }
      else if (is.getSystemId()!=null) {
        doctype = is.getSystemId();
	    }
      parser.parse(is);
      DefaultMutableTreeNode rt = (DefaultMutableTreeNode)treeModel.getRoot();
      doctype = ((NodeInfo)rt.getUserObject()).toString();
      System.out.println("doctype = " + doctype);
      } 
      catch (Exception e) { 
        System.err.println(e.toString());
      }
    }
}

	public DefaultMutableTreeNode newNode (Object name) {
	    NodeInfo ni = new NodeInfo(name.toString());
	    DefaultMutableTreeNode node = new DefaultMutableTreeNode(ni);
	    return node;
	}
	
	class SymTreeSelection implements javax.swing.event.TreeSelectionListener
	{
		public  void valueChanged(javax.swing.event.TreeSelectionEvent event)
		{
			Object object = event.getSource();
			if (object == tree)
				tree_valueChanged(event);
		}
	}

	 void tree_valueChanged(javax.swing.event.TreeSelectionEvent event)
	{
	    TreePath tp = event.getNewLeadSelectionPath();
	    if (tp!=null) {
	    Object ob = tp.getLastPathComponent();
	    DefaultMutableTreeNode node = null;
	    if (ob!=null) {node =(DefaultMutableTreeNode)ob;}
         selectedNode = node;
         XMLPanels xp = new XMLPanels(node);
         xp.setTreeModel(treeModel);
         NestedPanelScrollPanel.getViewport().add(xp.topPanel);
         xp.invalidate();
         NestedPanelScrollPanel.repaint();
		}
	}  

	class SymChange implements javax.swing.event.ChangeListener
	{
		public void stateChanged(javax.swing.event.ChangeEvent event)
		{
		}
	}
	
	class PopupListener extends MouseAdapter {
    // on the Mac, popups are triggered on mouse pressed, while mouseReleased triggers them
    // on the PC; use the trigger flag to record a trigger, but do not show popup until the
    // mouse released event
    boolean trigger = false;
    public void mousePressed(MouseEvent e) {
      // maybeShowPopup(e);
      if (e.isPopupTrigger()) {
        trigger = true;
      }  
    }

    public void mouseReleased(MouseEvent e) {
      maybeShowPopup(e);
    }

    private void maybeShowPopup(MouseEvent e) {
      if ((e.isPopupTrigger())||(trigger)) {
        trigger = false;
        TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());
        tree.setSelectionPath(selPath);
        if (selectedNode!=null) {
          NodeInfo ni = (NodeInfo)selectedNode.getUserObject();
          String temp = (String)ni.attr.get("copyNode");
          if ((temp!=null)&&(temp.equalsIgnoreCase("false"))){
            DupmenuItem.setEnabled(false);   
          }
          else {
            DupmenuItem.setEnabled(true); 
          }
          temp = (String)ni.attr.get("deleteNode");
          if ((temp!=null)&&(temp.equalsIgnoreCase("false"))){
            DeletemenuItem.setEnabled(false);   
          }
          else {
            DeletemenuItem.setEnabled(true); 
          }
        }
        popup.show(e.getComponent(), e.getX(), e.getY());
      }
    }
              
  }	
	
	
public DefaultMutableTreeNode deepNodeCopy(DefaultMutableTreeNode node) {
  DefaultMutableTreeNode newnode = null; 
  try{
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    ObjectOutputStream s = new ObjectOutputStream(out);
    s.writeObject(node);
    s.flush();
        
    // now read it
    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
    ObjectInputStream os = new ObjectInputStream(in);
    newnode = (DefaultMutableTreeNode)os.readObject();
    }
    catch (Exception e) {
      System.out.println("Exception in creating copy of node!");
    }
  return newnode;
}
	
	
void Dup_actionPerformed(java.awt.event.ActionEvent event) {
  TreePath tp = tree.getSelectionPath();
	if (tp!=null) {
	  Object ob = tp.getLastPathComponent();
	  DefaultMutableTreeNode node = (DefaultMutableTreeNode)ob;
	  DefaultMutableTreeNode par = (DefaultMutableTreeNode)node.getParent();
	  int iii = par.getIndex(node);
	  DefaultMutableTreeNode newnode = deepNodeCopy(node);
	  tree.expandPath(tp);
	  par.insert(newnode,iii);
	  treeModel.reload(par);
	}
}

void Del_actionPerformed(java.awt.event.ActionEvent event) {
  TreePath currentSelection = tree.getSelectionPath();
  if (currentSelection != null) {
    DefaultMutableTreeNode currentNode = (DefaultMutableTreeNode)(currentSelection.getLastPathComponent());
    NodeInfo ni = (NodeInfo)currentNode.getUserObject();
    String curNodeName = ni.getName();
    int cnt = 0;
    MutableTreeNode parent = (MutableTreeNode)(currentNode.getParent());
    if (parent != null) {
      Enumeration eee = parent.children();
      while (eee.hasMoreElements()) {
        DefaultMutableTreeNode cn = (DefaultMutableTreeNode)eee.nextElement();
        NodeInfo ni1 = (NodeInfo)cn.getUserObject();
        String name = ni1.getName();
        if (name.equals(curNodeName)) {
          cnt++;
        }
      }
    }
    if ((parent != null)&&(cnt>1)) {
      treeModel.removeNodeFromParent(currentNode);
      return;
    }
  } 

  // Either there was no selection, or the root was selected.
  Toolkit.getDefaultToolkit().beep();
}	
	

void reload_actionPerformed(java.awt.event.ActionEvent event)
	{
		treeModel.reload();
		tree.setModel(treeModel);
		
	}
	

	void DTDParse_actionPerformed(java.awt.event.ActionEvent event)
	{
		DTDTree dtdtree = new DTDTree("./catalog/resource.dtd");
		dtdtree.parseDTD();
		tree.setModel(dtdtree.treeModel);
	}
}